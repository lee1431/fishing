<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>빙어낚시 — 채비 선택(찌/끝보기) & 구멍별 장착</title>
  <style>
    :root{ --bg:#e9f6ff; --ice:#dff1ff; --ink:#213547; --cute:#ff8fb1; --accent:#82d9a7; --ui:#ffffffcc; }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#fdfcff);}    
    body{display:flex;align-items:center;justify-content:center;font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,"Apple SD Gothic Neo","Noto Sans KR","Nanum Gothic",sans-serif;color:var(--ink)}
    #wrap{position:relative;width:min(1000px,96vw);height:min(720px,82vh);}    
    canvas{position:absolute;inset:0;border-radius:16px;box-shadow:0 8px 30px rgba(0,0,0,.08);background:var(--ice);touch-action:none}
    .hud{position:absolute;inset:0;pointer-events:none;padding:10px;}
    .topbar{display:flex;gap:10px;align-items:center;}
    .badge{pointer-events:auto;background:var(--ui);backdrop-filter: blur(6px); padding:6px 10px;border-radius:999px;border:1px solid #00000012;box-shadow:0 2px 8px rgba(0,0,0,.06);display:flex;align-items:center;gap:8px;font-weight:600}
    .right{margin-left:auto;display:flex;gap:8px}
    button{pointer-events:auto;border:0;border-radius:999px;padding:8px 14px;font-weight:700;cursor:pointer}
    button.cute{background:var(--cute);color:white;box-shadow:0 6px 14px rgba(255,143,177,.3)}
    button.ghost{border:1px solid #00000016;background:var(--ui)}
    button.toggle.on{background:var(--accent);color:#083d2b}
    .bottombar{position:absolute;left:0;right:0;bottom:10px;display:flex;justify-content:center;gap:10px}
    .pill{pointer-events:none; position:absolute; top:52px; left:10px; background:var(--ui); border:1px solid #00000012; padding:6px 10px; border-radius:999px; font-weight:700}
    .toast{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:var(--ui);padding:14px 18px;border-radius:12px;border:1px solid #00000014;box-shadow:0 8px 30px rgba(0,0,0,.08);font-weight:700}
    /* Gear palette */
    .gear{position:absolute; left:10px; top:92px; background:var(--ui); border:1px solid #00000014; border-radius:14px; padding:10px; pointer-events:auto; display:flex; gap:10px; align-items:center;}
    .gear .group{display:flex; gap:6px; align-items:center;}
    .gear .title{font-weight:800; font-size:12px; opacity:.8; margin-right:6px}
    .gear button{padding:6px 10px; border-radius:10px; background:#fff; border:1px solid #00000016; font-weight:700}
    .gear button.sel{background:#3b82f6; color:#fff; border-color:#2b6ad9}
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="990" height="700"></canvas>
    <div class="hud">
      <div class="topbar">
        <div class="badge">🎣 점수: <span id="score">0</span></div>
        <div class="badge">✨ 콤보: <span id="combo">0</span>x</div>
        <div class="badge">🧤 체온: <span id="temp">100</span>%</div>
        <div class="badge">🧳 가방: 낚시대 <span id="rods">3</span>대</div>
        <div class="right">
          <button id="augerBtn" class="ghost toggle">🌀 아이스오거</button>
          <button id="dayNight" class="ghost">🌞 낮</button>
          <button id="reset" class="ghost">🔄 다시하기</button>
        </div>
      </div>
      <div class="pill">활성 구멍: <span id="activeIdx">-</span> · 숫자키(1–9) 전환 · R: 장착/해제 · ↓: 내리기 · Space: 챔질 · ↑/W: 릴링</div>

      <!-- Gear palette -->
      <div class="gear" id="gear">
        <div class="group">
          <span class="title">릴</span>
          <button data-reel="spinning" class="sel">스피닝</button>
          <button data-reel="baitcasting">베이트</button>
          <button data-reel="handline">견지</button>
        </div>
        <div class="group">
          <span class="title">표현</span>
          <button data-mode="float">찌</button>
          <button data-mode="tip" class="sel">끝보기</button>
        </div>
        <div class="group" style="opacity:.75;font-size:12px;font-weight:700">선택된 조합이 새로 장착(R)될 때 적용</div>
      </div>


       <div class="bottombar">
        <button class="cute" id="dropBtn"></button>
        <button class="cute" id="liftBtn"></button>
      </div>
      <div class="toast" id="toast" hidden></div>
    </div>
  </div>

<script>
(function(){
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const dpr = Math.max(1, window.devicePixelRatio||1);
  function fit(){ const w = canvas.clientWidth, h = canvas.clientHeight; canvas.width=Math.round(w*dpr); canvas.height=Math.round(h*dpr); ctx.setTransform(dpr,0,0,dpr,0,0);} new ResizeObserver(fit).observe(canvas); fit();

  // ★ 상태 확장: REEL(릴링), LANDED(랜딩-파닥)
  const ST = { READY:1, WAIT:2, BITE:3, HOOK:4, REEL:5, LANDED:6 };
  let mode = 'FISH'; let time=0; let score=0, combo=0, temp=100; let day=true;

  const holes = []; // per-hole
  /* hole: {x,y,r,ripple, rod:boolean, rig:{reel,mode}, line:{depth,target}, state, biteTimer, hookWindow, fishTarget, bitePhase, biteT, biteAmp, biteDown, frenzyLeft, xJitter, tipBaseSag, reel?} */
  let activeHole = -1; let rodsBagMax=3, rodsBagNow=3; let mouse={x:0.5,y:0.4};

  const fishList=[]; const MAX_FISH=6;

  // UI refs
  const elScore = document.getElementById('score');
  const elCombo = document.getElementById('combo');
  const elTemp  = document.getElementById('temp');
  const elRods  = document.getElementById('rods');
  const elActiveIdx = document.getElementById('activeIdx');
  const toast   = document.getElementById('toast');
  const dropBtn = document.getElementById('dropBtn');
  const liftBtn = document.getElementById('liftBtn');
  const resetBtn= document.getElementById('reset');
  const dayBtn  = document.getElementById('dayNight');
  const augerBtn= document.getElementById('augerBtn');

  // 릴링 입력
  const input = { reel:false };

  // Gear palette state
  const gear = { reel:'spinning', mode:'tip' };
  const gearPanel = document.getElementById('gear');
  gearPanel.addEventListener('click',(e)=>{
    const b = e.target.closest('button'); if(!b) return;
    if(b.dataset.reel){ gear.reel=b.dataset.reel; [...gearPanel.querySelectorAll('button[data-reel]')].forEach(x=>x.classList.toggle('sel', x===b)); }
    if(b.dataset.mode){ gear.mode=b.dataset.mode; [...gearPanel.querySelectorAll('button[data-mode]')].forEach(x=>x.classList.toggle('sel', x===b)); }
  });

  const drills=[]; // auger anim
  function rand(a,b){return a+Math.random()*(b-a)}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
  function lerp(a,b,t){return a+(b-a)*t}

  function spawnFish(){ if(fishList.length>=MAX_FISH) return; const side=Math.random()<.5?-1:1; const y=rand(0.45,0.9); const speed=rand(0.2,0.5)*(Math.random()<.5?1:-1); const scale=rand(0.8,1.3); fishList.push({ x: side<0?-0.2:1.2, y, v: speed*0.0025, s:scale, dir: side<0?1:-1, mood:'cruise', blink:0, tilt:0 }); }
  function pickBiter(){ if(fishList.length===0) return null; const near = fishList.filter(f=>Math.abs(f.y - 0.58) < 0.25); return near.length? near[(Math.random()*near.length)|0] : fishList[(Math.random()*fishList.length)|0]; }

  // Controls
  resetBtn.addEventListener('click', reset);
  dayBtn.addEventListener('click', ()=>{ day=!day; dayBtn.textContent = day? '🌞 낮':'🌙 밤'; });
  augerBtn.addEventListener('click', ()=>{ if(mode==='AUGER'){ mode='FISH'; augerBtn.classList.remove('on'); hideToast(); } else { mode='AUGER'; augerBtn.classList.add('on'); showToast('오거 모드: 원하는 위치로 이동 후 클릭!'); }});
  dropBtn.addEventListener('click', ()=> dropActive());
  liftBtn.addEventListener('click', ()=> hookActive());
  window.addEventListener('keydown', (e)=>{ const n=parseInt(e.key,10); if(n>=1 && n<=holes.length){ setActive(n-1);} if(e.key===' '){ e.preventDefault(); hookActive(); } if(e.key==='r'||e.key==='R'){ toggleRodAtActive(); } if(e.key==='ArrowDown'){ dropActive(); }
    if(e.key==='ArrowUp'||e.key==='w'||e.key==='W'){ input.reel=true; }});
  window.addEventListener('keyup', (e)=>{ if(e.key==='ArrowUp'||e.key==='w'||e.key==='W'){ input.reel=false; }});
  canvas.addEventListener('pointermove', (e)=>{ const r=canvas.getBoundingClientRect(); mouse.x=(e.clientX-r.left)/r.width; mouse.y=(e.clientY-r.top)/r.height; });
  canvas.addEventListener('pointerdown', (e)=>{
    const r=canvas.getBoundingClientRect();
    const xNorm=(e.clientX-r.left)/r.width; const yNorm=(e.clientY-r.top)/r.height;

    // ★ 랜딩 상태에서 물고기 클릭 → 바늘 빼기
    if(activeHole!==-1){
      const ah = holes[activeHole];
      if(ah && ah.state===ST.LANDED && hitLandedFish(ah, canvas.width*xNorm, canvas.height*yNorm)){
        unhook(ah);
        return;
      }
    }

    if(mode==='AUGER'){ startDrill(xNorm,yNorm); return; }
    const idx=hitHole(xNorm,yNorm);
    if(idx!==-1){ setActive(idx); return; }
    hookActive();
  });

  function hitHole(x,y){ for(let i=holes.length-1;i>=0;i--){ const h=holes[i]; const dx=(x-h.x)*canvas.clientWidth, dy=(y-h.y)*canvas.clientHeight; const rx=h.r, ry=h.r*0.62; if((dx*dx)/(rx*rx)+(dy*dy)/(ry*ry)<=1) return i; } return -1; }
  function setActive(i){ activeHole=i; elActiveIdx.textContent=(i+1); showToast(`활성 구멍 ${i+1}`); }

  // Auger / Drill
  function startDrill(x,y){ const minY=0.28; if(y<minY){ showToast('조금 더 아래(얼음)에서 뚫어봐요!'); return; } drills.push({x,y,progress:0,spin:0,shavings:[]}); mode='DRILL'; showToast('드르륵… 구멍 파는 중'); }
  function updateDrills(dt){ for(let i=drills.length-1;i>=0;i--){ const d=drills[i]; d.progress+=dt*0.7; d.spin+=dt*16; if(Math.random()<0.5){ d.shavings.push({x:rand(-6,6),y:rand(-6,6),v:rand(12,28),a:1}); } d.shavings.forEach(s=>{ s.y += s.v*dt; s.a -= dt*0.8;}); d.shavings=d.shavings.filter(s=>s.a>0); if(d.progress>=1){ drills.splice(i,1); const r=68; const h={x:d.x,y:d.y,r, ripple:0, rod:false, rig:null, line:{depth:0,target:20}, state:ST.READY, biteTimer:rand(3.5,7.5), hookWindow:0, fishTarget:null, bitePhase:0, biteT:0, biteAmp:0, biteDown:0, frenzyLeft:0, xJitter:0, tipBaseSag:0}; holes.push(h); if(activeHole===-1) setActive(0); showToast('🕳️ 구멍 완성! (숫자키 전환, R 장착)'); mode='AUGER'; } } }

  // Fishing per hole
  function dropActive(){ if(activeHole===-1) return; const h=holes[activeHole]; if(!h.rod){ showToast('이 구멍에 낚시대를 먼저 장착하세요 (R)'); return; } if(h.state===ST.READY||h.state===ST.WAIT){ h.line.target= (h.rig && h.rig.mode==='float')? 120 : 60; h.biteTimer=rand(3.5,7.5); resetBite(h); h.state=ST.WAIT; showToast('⬇️ 내렸습니다'); } }
  function hookActive(){ if(activeHole===-1) return; const h=holes[activeHole]; if(!h.rod) return; if(h.state===ST.HOOK){ startReel(h); } else { miss(h); } }
  function toggleRodAtActive(){ if(activeHole===-1) return; const h=holes[activeHole]; if(h.rod){ h.rod=false; rodsBagNow=clamp(rodsBagNow+1,0,rodsBagMax); showToast('🎒 장비 회수'); } else { if(rodsBagNow<=0){ showToast('가방에 남은 낚시대가 없어요!'); return; } h.rod=true; h.rig={reel:gear.reel, mode:gear.mode}; rodsBagNow--; h.line.target=(h.rig.mode==='float')?120:60; h.state=ST.WAIT; h.biteTimer=rand(3.5,7.5); resetBite(h); showToast(`🪝 ${labelRig(h.rig)} 장착 & 대기`); } elRods.textContent=rodsBagNow; }

  function labelRig(r){ const reel = r.reel==='spinning'?'스피닝': r.reel==='baitcasting'?'베이트':'견지'; const mode=r.mode==='float'?'찌':'끝보기'; return `${reel} · ${mode}`; }
  function resetBite(h){ h.bitePhase=0; h.biteT=0; h.biteAmp=0; h.biteDown=0; h.frenzyLeft=0; h.xJitter=0; }

  // 캐치(점수 처리) — (이제) 바늘 빼기 클릭에서 호출
  function catchFish(h){
    const gain=10+Math.floor(combo*1.5);
    score+=gain; combo+=1; temp=clamp(temp+6,0,100);
    elScore.textContent=score; elCombo.textContent=combo; elTemp.textContent=Math.round(temp);
    showToast(`🐟 [${holes.indexOf(h)+1}] 빙어 획득! +${gain}`);
    h.ripple=0.001;
    h.line.target=(h.rig?.mode==='float')?20:40;
    if(h.fishTarget){ h.fishTarget.mood='cruise'; h.fishTarget.tilt=0.2; setTimeout(()=>{ if(h.fishTarget) h.fishTarget.tilt=0; }, 250);}
    h.biteTimer=rand(4.0,8.0);
    h.state=ST.WAIT;
    delete h.reel;
    resetBite(h);
  }

  function miss(h){ combo=0; elCombo.textContent=combo; showToast(`😮‍💨 [${holes.indexOf(h)+1}] 놓쳤다…`); h.state=ST.WAIT; h.biteTimer=rand(4.5,8.5); if(h.fishTarget) h.fishTarget.mood='cruise'; resetBite(h); }

  function startReel(h){
    h.state = ST.REEL;
    h.reel = { progress:0, tension:0, spool:0, fightT:0, stamina:1.0, flopT:0, splashes:[] };
    showToast('릴링 시작! ↑/W 키로 감으세요 · 랜딩 후 물고기 클릭: 바늘 빼기');
  }

  function unhook(h){
    // 랜딩 상태에서 물고기 클릭 → 점수 반영 + 낚시 대기
    catchFish(h);
  }

  function update(dt){
    time+=dt; temp=Math.max(0,temp-dt*0.9); if(Math.random()<0.02) spawnFish();
    for(const f of fishList){ f.x += f.v*dt*60; f.y += Math.sin((time*0.6 + f.x*7))*0.0008; f.blink = (Math.sin(time*5 + f.x*13) > 0.92)?1:0; if(f.x < -0.25 && f.v<0) f.v*=-1, f.dir=1; if(f.x > 1.25 && f.v>0) f.v*=-1, f.dir=-1; }

    for(const h of holes){
      h.line.depth = lerp(h.line.depth, h.line.target, 0.08);

      // 로드 기본 처짐(채비별)
      if(h.rig){
        const targetSag = (h.rig.mode==='tip')
              ? (h.line.target>40 ? 12 : 6)
              : (h.line.target>40 ? 8 : 3); // float: 덜 처짐, 입질 영향 없음
        h.tipBaseSag = lerp(h.tipBaseSag||0, targetSag, 0.08);
      } else {
        h.tipBaseSag = lerp(h.tipBaseSag||0, 0, 0.1);
      }

      if(!h.rod){ h.ripple=Math.max(0,(h.ripple||0)-dt*0.6); continue; }

      // 기존 로직: WAIT→BITE→HOOK
      if(h.state===ST.WAIT){ h.biteTimer -= dt; if(h.biteTimer<=0){ h.fishTarget = pickBiter(); h.ripple=0.001; h.bitePhase=1; h.biteT=0; h.biteAmp=6; h.state=ST.BITE; }}
      if(h.state===ST.BITE || h.state===ST.HOOK){
        h.ripple += dt*(h.state===ST.HOOK?1.8:1.5); if(h.ripple>1.2) h.ripple=0; h.biteT += dt;
        const tok=(amp,t)=> Math.max(0, amp*Math.exp(-t*14)*Math.sin(t*40)); h.biteDown = tok(h.biteAmp, h.biteT);
        const targetJit=(h.bitePhase===3?3:1.2); h.xJitter = lerp(h.xJitter||0, Math.sin(time*2.2)*targetJit, 0.15);
        if(h.bitePhase===1 && h.biteT>0.18){ h.bitePhase=2; h.biteT=0; h.biteAmp=10; }
        else if(h.bitePhase===2 && h.biteT>0.22){ h.state=ST.HOOK; h.hookWindow = 0.8 + Math.random()*0.6; if(Math.random()<0.5){ h.bitePhase=3; h.biteT=0; h.biteAmp=8; h.frenzyLeft = 3 + (Math.random()*4|0);} else { h.bitePhase=0; } }
        else if(h.bitePhase===3){ if(h.biteT>0.14){ h.biteT=0; h.frenzyLeft--; h.biteAmp = 7 + Math.random()*3; } if(h.frenzyLeft<=0){ h.bitePhase=0; } h.hookWindow -= dt; if(h.hookWindow<=0 && h.state===ST.HOOK){ miss(h); } }
        else if(h.state===ST.HOOK && h.bitePhase===0){ h.hookWindow -= dt; if(h.hookWindow<=0){ miss(h); } }
      }

      // ★ 릴링 단계
      if(h.state===ST.REEL && h.reel){
        const r=h.reel;
        r.fightT += dt;
        const jerk = Math.max(0, Math.sin(r.fightT*11)) * 0.35 * r.stamina; // 물고기 저항
        r.stamina = Math.max(0.5, r.stamina - dt*0.03);

        // 감기
        const reelSpeed = input.reel ? 0.55 : 0.0; // 감는 속도(초당)
        r.progress = Math.min(1, r.progress + (reelSpeed - jerk*0.25) * dt);
        r.spool += reelSpeed * dt * 18;

        // 텐션
        const add = (input.reel? 0.45:0) + jerk*0.6;
        r.tension = Math.max(0, Math.min(1.2, r.tension + (add - 0.35)*dt));

        // 로드 하중(끝보기에서 더 크게 보임)
        const loadSag = (h.rig?.mode==='tip' ? 18 : 8) * r.tension;
        h.tipBaseSag = lerp(h.tipBaseSag, loadSag, 0.15);

        // 텐션 과다 오래 유지 → 라인 파손
        if(r.tension > 1.0){
          r.redZone = (r.redZone||0) + dt;
          if(r.redZone > 0.6){ miss(h); continue; }
        } else { r.redZone = 0; }

        if(Math.random()<0.08) r.splashes.push({t:0});

        // 완료 → 랜딩(파닥)
        if(r.progress >= 1){ h.state = ST.LANDED; r.flopT = 0; showToast('랜딩! 물고기를 클릭해 바늘을 빼세요'); }
      }

      // ★ 랜딩(파닥) — 클릭 대기
      if(h.state===ST.LANDED && h.reel){
        h.reel.flopT += dt;
        // 로드 하중 해제 방향으로
        h.tipBaseSag = lerp(h.tipBaseSag, (h.rig?.mode==='tip'? 6:3), 0.1);
      }

      if(h.state!==ST.BITE && h.state!==ST.HOOK){ h.ripple=Math.max(0,(h.ripple||0)-dt*0.8); h.biteDown=0; h.xJitter=lerp(h.xJitter||0,0,0.1); }
    }

    if(mode==='DRILL') updateDrills(dt);
    elRods.textContent=rodsBagNow;
  }

  // ---- RENDER ----
  function drawBackground(){ const {width:W,height:H} = canvas; const g=ctx.createLinearGradient(0,0,0,H); if(day){ g.addColorStop(0,'#eaf7ff'); g.addColorStop(1,'#ffffff'); } else { g.addColorStop(0,'#0b1736'); g.addColorStop(1,'#12214d'); } ctx.fillStyle=g; ctx.fillRect(0,0,W,H); const iceTop=H*0.28; ctx.fillStyle = day? '#dff3ff' : '#1a2b4d'; ctx.fillRect(0, iceTop, W, H-iceTop); ctx.globalAlpha = day?0.22:0.15; ctx.fillStyle='#ffffff'; for(let i=0;i<60;i++){ const x=(i*73+(time*22)%73)%W; const y= iceTop-10-(i*11%30); ctx.fillRect(x,y,3,3);} ctx.globalAlpha=1; }

  function drawHole(h,i){ const W=canvas.width,H=canvas.height; const cx=W*h.x, cy=H*h.y, r=h.r; ctx.save(); ctx.fillStyle= day?'#9bd3ff':'#0c2a47'; ctx.beginPath(); ctx.ellipse(cx, cy, r*1.15, r*0.8, 0,0,Math.PI*2); ctx.fill(); const g=ctx.createLinearGradient(0,cy-r,0,cy+r); g.addColorStop(0, day?'#bfe6ff':'#0c3f6b'); g.addColorStop(1, day?'#8fd2ff':'#0a2d4d'); ctx.fillStyle=g; ctx.beginPath(); ctx.ellipse(cx, cy, r, r*0.62, 0,0,Math.PI*2); ctx.fill(); ctx.lineWidth=8; ctx.strokeStyle= day?'#e8f7ff':'#224a73'; ctx.stroke(); if(h.ripple>0){ for(let k=0;k<3;k++){ const t=(h.ripple*1.2 - k*0.25); if(t<0) continue; ctx.globalAlpha=Math.max(0,1-t)*0.6; ctx.lineWidth=2; ctx.strokeStyle= day?'#ffffff':'#d0ecff'; ctx.beginPath(); ctx.ellipse(cx, cy+2, r*(1+t*0.6), r*0.62*(1+t*0.6), 0,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; }} if(i===activeHole){ ctx.strokeStyle='#ff8fb1'; ctx.lineWidth=2; ctx.setLineDash([6,6]); ctx.beginPath(); ctx.ellipse(cx, cy, r*1.25, r*0.9, 0,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([]); } ctx.fillStyle='#0008'; ctx.font='bold 12px system-ui'; ctx.textAlign='center'; const rigLbl = h.rig? (h.rig.mode==='float'?'찌':'끝') : ''; ctx.fillText(`${i+1}${h.rod?' ':''} ${rigLbl}`, cx, cy + r*0.85); ctx.restore(); }

  function drawRigFor(h){ if(!h.rod) return; if(!h.rig||h.rig.mode==='float') return drawFloatFor(h); else return drawTipFor(h); }

  // 찌 모드 (끝보기 스타일 + 찌만 반응)
  function drawFloatFor(h){
    const W=canvas.width,H=canvas.height; const cx=W*h.x, cy=H*h.y;
    const baseY = H*0.22; const bx = cx-162, by = baseY+10; const L=150;

    ctx.save();
    // 거치대
    ctx.lineWidth=3; ctx.strokeStyle= day?'#9aa3ad':'#6f7a86';
    ctx.beginPath();
    ctx.moveTo(bx, by+6); ctx.lineTo(bx+18, by-18); ctx.lineTo(bx+36, by+6);
    ctx.moveTo(bx, by+6); ctx.lineTo(bx, by+26); ctx.moveTo(bx+36, by+6); ctx.lineTo(bx+36, by+26);
    ctx.stroke();
    // 릴(간단 원형)
    ctx.beginPath(); ctx.lineWidth=4; ctx.strokeStyle= day?'#3b3e44':'#22252b'; ctx.arc(bx+20, by-22, 9, 0, Math.PI*2); ctx.stroke();
    // 스풀 회전 표시
    if(h.reel){ ctx.save(); ctx.translate(bx+20, by-22); ctx.rotate(h.reel.spool||0); ctx.strokeStyle= day?'#cfd3da':'#9aa3ad'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.moveTo(-6,0); ctx.lineTo(6,0); ctx.stroke(); ctx.restore(); }

    // 로드 곡선 (기본 처짐만)
    const sag = (h.tipBaseSag||0);
    const segs=14, pts=[];
    for(let i=0;i<=segs;i++){
      const t=i/segs;
      const px = bx + 20 + t*L;
      const baseSlope = by + 6 + t*10;
      const bend = sag * (t*t) * (0.35 + 0.65*t);
      const py = baseSlope + bend; pts.push({x:px,y:py});
    }
    for(let i=0;i<segs;i++){ const p=pts[i], q=pts[i+1]; const t=i/segs; ctx.lineWidth=7*(1-t*0.75); ctx.strokeStyle= day?'#3b2b1a':'#2e2319'; ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(q.x,q.y); ctx.stroke(); }
    for(let i=Math.floor(segs*0.7); i<segs; i++){ const p=pts[i], q=pts[i+1]; ctx.lineWidth=3; ctx.strokeStyle = h.rig && h.rig.reel==='baitcasting'? '#ffb26b' : (h.rig && h.rig.reel==='handline'? '#7bf0a3' : '#7bb2ff'); ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(q.x,q.y); ctx.stroke(); }

    // 팁 좌표
    const tip = pts[pts.length-1];

    // 직선 줄: 팁 → 얼음구멍 타원 경계
    const rx=(h.r||60), ry=rx*0.22;
    const ux=cx-tip.x, uy=cy-tip.y; const ulen=Math.hypot(ux,uy)||1; const vx=ux/ulen, vy=uy/ulen;
    const dx=tip.x-cx, dy=tip.y-cy;
    const A=(vx*vx)/(rx*rx)+(vy*vy)/(ry*ry);
    const B=2*((dx*vx)/(rx*rx)+(dy*vy)/(ry*ry));
    const C=(dx*dx)/(rx*rx)+(dy*dy)/(ry*ry)-1;
    const D=Math.max(0,B*B-4*A*C);
    let s=(-B+Math.sqrt(D))/(2*A); if(!(s>0)) s=(-B-Math.sqrt(D))/(2*A);
    const hx=tip.x+vx*s, hy=tip.y+vy*s;

    // 줄
    ctx.lineWidth=1.8; ctx.strokeStyle='rgba(255,255,255,0.9)';
    ctx.beginPath(); ctx.moveTo(tip.x, tip.y); ctx.lineTo(hx, hy); ctx.stroke();

    // 찌(입질만 반응)
    const floatDip = (h.biteDown||0);
    const bX = hx, bY = hy + floatDip - 10;
    ctx.translate(bX,bY);
    ctx.fillStyle='#ff6f91';
    ctx.beginPath(); ctx.ellipse(0,0,10,14,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff3'; ctx.fillRect(-2,-14,4,6);
    ctx.restore();
  }

  // 끝보기 모드
  function drawTipFor(h){
    const W=canvas.width,H=canvas.height; const cx=W*h.x, cy=H*h.y;
    const baseY = H*0.22;
    const bx = cx+152, by = baseY+10; const L = 150;

    ctx.save();
    // 거치대
    ctx.lineWidth=3; ctx.strokeStyle= day?'#9aa3ad':'#6f7a86';
    ctx.beginPath();
    ctx.moveTo(bx, by+6); ctx.lineTo(bx+18, by-18); ctx.lineTo(bx+36, by+6);
    ctx.moveTo(bx, by+6); ctx.lineTo(bx, by+26); ctx.moveTo(bx+36, by+6); ctx.lineTo(bx+36, by+26);
    ctx.stroke();
    // 릴
    ctx.beginPath(); ctx.lineWidth=4; ctx.strokeStyle= day?'#3b3e44':'#22252b';
    ctx.arc(bx+20, by-22, 9, 0, Math.PI*2); ctx.stroke();
    if(h.reel){ ctx.save(); ctx.translate(bx+20, by-22); ctx.rotate(h.reel.spool||0); ctx.strokeStyle= day?'#cfd3da':'#9aa3ad'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.moveTo(-6,0); ctx.lineTo(6,0); ctx.stroke(); ctx.restore(); }

    // 로드 곡선(끝보기: 팁에서 굽힘)
    const sag = (h.tipBaseSag||0) + (h.biteDown||0);
    const segs = 14, pts=[];
    for(let i=0;i<=segs;i++){
      const t = i/segs;
      const px = bx + 20 - t*L;
      const baseSlope = by + 6 + t*10;
      const bend = sag * (t*t) * (0.35 + 0.65*t);
      const py = baseSlope + bend;
      pts.push({x:px, y:py});
    }
    for(let i=0;i<segs;i++){
      const p=pts[i], q=pts[i+1];
      const t=i/segs;
      ctx.lineWidth = 7*(1-t*0.75);
      ctx.strokeStyle = day?'#3b2b1a':'#2e2319';
      ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(q.x,q.y); ctx.stroke();
    }
    for(let i=Math.floor(segs*0.7); i<segs; i++){
      const p=pts[i], q=pts[i+1];
      ctx.lineWidth = 3;
      ctx.strokeStyle = h.rig && h.rig.reel==='baitcasting'? '#ffb26b' : (h.rig && h.rig.reel==='handline'? '#7bf0a3' : '#7bb2ff');
      ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(q.x,q.y); ctx.stroke();
    }

    // 줄(곡선 유지 — 끝보기 현장 감)
    const tip = pts[pts.length-1];
    ctx.lineWidth=1.6; ctx.strokeStyle='rgba(255,255,255,0.8)';
    ctx.beginPath();
    ctx.moveTo(tip.x, tip.y);
    ctx.quadraticCurveTo(cx+8, cy-60 + sag*0.18, cx, cy);
    ctx.stroke();

    // 팁 점
    ctx.beginPath(); ctx.arc(tip.x, tip.y, 3.5, 0, Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.85)'; ctx.fill();
    ctx.restore();
  }

  function drawAugerCursor(){ if(mode!=='AUGER') return; const W=canvas.width,H=canvas.height; const cx=W*mouse.x, cy=H*mouse.y; const r=70; ctx.save(); ctx.globalAlpha=0.5; ctx.fillStyle='#0004'; ctx.fillRect(0,0,W,H); ctx.globalCompositeOperation='destination-out'; let grd=ctx.createRadialGradient(cx,cy,10,cx,cy,r); grd.addColorStop(0,'rgba(0,0,0,1)'); grd.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.restore(); ctx.save(); ctx.strokeStyle='#2b5'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(cx,cy,r*0.9,0,Math.PI*2); ctx.stroke(); ctx.lineWidth=2; ctx.strokeStyle='#0a0'; ctx.beginPath(); ctx.arc(cx,cy,r*0.5, time*2, time*2+Math.PI*1.2); ctx.stroke(); ctx.restore(); }
  function drawDrills(){ for(const d of drills){ const W=canvas.width,H=canvas.height; const cx=W*d.x, cy=H*d.y; const r= 70*(0.9+0.1*Math.sin(time*10)); ctx.save(); ctx.translate(cx,cy); ctx.rotate(d.spin); ctx.fillStyle='#444'; for(let i=0;i<3;i++){ ctx.rotate((Math.PI*2)/3); ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(22,6); ctx.lineTo(6,22); ctx.closePath(); ctx.fill(); } ctx.restore(); ctx.save(); ctx.translate(cx,cy); for(const s of d.shavings){ ctx.globalAlpha=Math.max(0,s.a); ctx.beginPath(); ctx.arc(s.x, s.y, 2.2, 0, Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); } ctx.restore(); ctx.save(); ctx.strokeStyle='#ff8fb1'; ctx.lineWidth=4; ctx.beginPath(); ctx.arc(cx,cy,40, -Math.PI/2, -Math.PI/2 + d.progress*2*Math.PI); ctx.stroke(); ctx.restore(); } }

  function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground();
    holes.forEach((h,i)=> drawHole(h,i));

    // 수중 배경 안 물고기
    if(activeHole!==-1){
      const h=holes[activeHole];
      const cx=canvas.width*h.x, cy=canvas.height*h.y, rx=h.r, ry=h.r*0.62;
      ctx.save(); ctx.beginPath(); ctx.ellipse(cx, cy, rx, ry, 0,0,Math.PI*2); ctx.clip();
      ctx.fillStyle = day? 'rgba(120,190,255,0.18)' : 'rgba(30,80,140,0.28)';
      ctx.fillRect(0, cy-ry, canvas.width, ry*2);
      for(const f of fishList){
        const W=canvas.width,H=canvas.height; const x=f.x*W, y=f.y*H; const dir=f.dir;
        ctx.save(); ctx.translate(x,y); ctx.scale(dir*f.s, f.s); ctx.rotate(f.tilt||0);
        ctx.fillStyle = day? '#c8f2ff':'#9fd1ff'; roundRect(-22,-8,44,18,9); ctx.fill();
        ctx.beginPath(); ctx.moveTo(-26,0); ctx.quadraticCurveTo(-40,-14,-34,0); ctx.quadraticCurveTo(-40,14,-26,0);
        ctx.fillStyle= day?'#a8e6ff':'#86bfff'; ctx.fill();
        ctx.fillStyle='#ffd5e5'; ctx.beginPath(); ctx.arc(6,2,4,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#233'; if(f.blink>0){ ctx.fillRect(10,-1,6,2);} else { ctx.beginPath(); ctx.arc(12,-1,3,0,Math.PI*2); ctx.fill(); }
        ctx.fillStyle='#fff8'; ctx.fillRect(6,-4,3,3); ctx.fillStyle='#233'; if(f.mood==='bite') ctx.fillRect(20,-2,4,4); else ctx.fillRect(20,-1,3,2);
        ctx.restore();
      }
      ctx.restore();
    }

    holes.forEach(h=> drawRigFor(h));

    // ★ 릴링/랜딩 비주얼
    if(activeHole!==-1){
      const h=holes[activeHole];
      if(h && (h.state===ST.REEL || h.state===ST.LANDED)){
        drawHookedFishAtHole(h);
        if(h.state===ST.REEL) drawTensionUI(h);
      }
    }

    drawDrills();
    drawAugerCursor();
    elScore.textContent=score; elCombo.textContent=combo; elTemp.textContent=Math.round(temp);
  }

  function roundRect(x,y,w,h,r){ const rr=Math.min(r,Math.abs(w)/2,Math.abs(h)/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); }

  // ★ 랜딩/릴링 시 시각 요소
  function drawHookedFishAtHole(h){
    const W=canvas.width,H=canvas.height;
    const cx=W*h.x, cy=H*h.y;
    const r = h.r || 60, ry = r*0.62;
    const prog = h.reel?.progress || 0;
    const y = cy + lerp(18, -12, prog);
    const x = cx + Math.sin(time*20) * (h.state===ST.LANDED? 2 : 1.5);

    // 물튀김 링
    if(h.reel){
      for(const s of h.reel.splashes){ s.t+=0.016; }
      h.reel.splashes = h.reel.splashes.filter(s=> s.t<0.5);
      h.reel.splashes.forEach(s=>{
        const a = 1 - s.t*2;
        ctx.globalAlpha = Math.max(0,a);
        ctx.strokeStyle = day?'#ffffff':'#d0ecff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(cx, cy+2, r*(0.6+ s.t*0.4), ry*(0.6+ s.t*0.4), 0,0,Math.PI*2);
        ctx.stroke();
        ctx.globalAlpha=1;
      });
    }

    // 리더(짧은 줄)
    ctx.lineWidth=1.4; ctx.strokeStyle='rgba(255,255,255,0.9)';
    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(x, y); ctx.stroke();

    // 물고기(파닥)
    ctx.save();
    ctx.translate(x, y);
    const flop = (h.state===ST.LANDED) ? Math.sin((h.reel?.flopT||0)*30)*0.25 : 0;
    ctx.rotate(flop);
    ctx.scale(0.9,0.9);
    ctx.fillStyle = day? '#c8f2ff':'#9fd1ff';
    roundSmall(-18,-6,36,13,7); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(-20,0); ctx.quadraticCurveTo(-32,-10,-28,0); ctx.quadraticCurveTo(-32,10,-20,0);
    ctx.fillStyle= day?'#a8e6ff':'#86bfff'; ctx.fill();
    ctx.fillStyle='#233'; ctx.beginPath(); ctx.arc(10,-1,2.2,0,Math.PI*2); ctx.fill();
    ctx.restore();

    function roundSmall(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  }

  function drawTensionUI(h){
    if(!h.reel) return;
    const W=canvas.width,H=canvas.height;
    const cx=W*h.x, cy=H*h.y;
    const t = Math.min(1, h.reel.tension||0);
    ctx.save();
    ctx.translate(cx+70, cy-80);
    ctx.fillStyle='#00000022'; ctx.fillRect(-36,-10,72,20);
    ctx.fillStyle = t>0.9 ? '#ff6b6b' : (t>0.6 ? '#ffd166' : '#82d9a7');
    ctx.fillRect(-34,-8, 68*t, 16);
    ctx.strokeStyle='#00000030'; ctx.strokeRect(-36,-10,72,20);
    ctx.font='bold 11px system-ui'; ctx.fillStyle='#223'; ctx.fillText('Tension',-16,-14);
    ctx.restore();
  }

  function hitLandedFish(h, px, py){
    if(!h.reel) return false;
    const W=canvas.width,H=canvas.height;
    const cx=W*h.x, cy=H*h.y;
    const prog = h.reel.progress||0;
    const y = cy + lerp(18, -12, prog);
    const x = cx + Math.sin(time*20) * (h.state===ST.LANDED? 2 : 1.5);
    const dx=px-x, dy=py-y;
    return dx*dx + dy*dy <= 26*26; // 반경 ~26px
  }

  function showToast(txt){ toast.hidden=false; txt && (toast.textContent=txt); clearTimeout(showToast._t); showToast._t=setTimeout(()=> toast.hidden=true, 1200); }
  function hideToast(){ toast.hidden=true; }

  function reset(){ score=0; combo=0; temp=100; rodsBagNow=rodsBagMax; time=0; holes.length=0; activeHole=-1; drills.length=0; fishList.length=0; for(let i=0;i<4;i++) spawnFish(); elRods.textContent=rodsBagNow; mode='FISH'; augerBtn.classList.remove('on'); showToast('오거로 구멍을 만들고(R) 장착해 보세요!'); }

  reset();
  let last=performance.now();
  (function loop(now){ const dt=Math.min(0.033,(now-last)/1000); last=now; update(dt); render(); requestAnimationFrame(loop); })(performance.now());
})();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>빙어낚시 — 채비 선택(찌/끝보기) & 구멍별 장착</title>
  <style>
    :root{ --bg:#e9f6ff; --ice:#dff1ff; --ink:#213547; --cute:#ff8fb1; --accent:#82d9a7; --ui:#ffffffcc; }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#fdfcff);}    
    body{display:flex;align-items:center;justify-content:center;font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,"Apple SD Gothic Neo","Noto Sans KR","Nanum Gothic",sans-serif;color:var(--ink)}
    #wrap{position:relative;width:min(1000px,96vw);height:min(720px,82vh);}    
    canvas{position:absolute;inset:0;border-radius:16px;box-shadow:0 8px 30px rgba(0,0,0,.08);background:var(--ice);touch-action:none}
    .hud{position:absolute;inset:0;pointer-events:none;padding:10px;}
    .topbar{display:flex;gap:10px;align-items:center;}
    .badge{pointer-events:auto;background:var(--ui);backdrop-filter: blur(6px); padding:6px 10px;border-radius:999px;border:1px solid #00000012;box-shadow:0 2px 8px rgba(0,0,0,.06);display:flex;align-items:center;gap:8px;font-weight:600}
    .right{margin-left:auto;display:flex;gap:8px}
    button{pointer-events:auto;border:0;border-radius:999px;padding:8px 14px;font-weight:700;cursor:pointer}
    button.cute{background:var(--cute);color:white;box-shadow:0 6px 14px rgba(255,143,177,.3)}
    button.ghost{border:1px solid #00000016;background:var(--ui)}
    button.toggle.on{background:var(--accent);color:#083d2b}
    .bottombar{position:absolute;left:0;right:0;bottom:10px;display:flex;justify-content:center;gap:10px}
    .pill{pointer-events:none; position:absolute; top:52px; left:10px; background:var(--ui); border:1px solid #00000012; padding:6px 10px; border-radius:999px; font-weight:700}
    .toast{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:var(--ui);padding:14px 18px;border-radius:12px;border:1px solid #00000014;box-shadow:0 8px 30px rgba(0,0,0,.08);font-weight:700}
    /* Gear palette */
    .gear{position:absolute; left:10px; top:92px; background:var(--ui); border:1px solid #00000014; border-radius:14px; padding:10px; pointer-events:auto; display:flex; gap:10px; align-items:center;}
    .gear .group{display:flex; gap:6px; align-items:center;}
    .gear .title{font-weight:800; font-size:12px; opacity:.8; margin-right:6px}
    .gear button{padding:6px 10px; border-radius:10px; background:#fff; border:1px solid #00000016; font-weight:700}
    .gear button.sel{background:#3b82f6; color:#fff; border-color:#2b6ad9}
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="990" height="700"></canvas>
    <div class="hud">
      <div class="topbar">
        <div class="badge">🎣 점수: <span id="score">0</span></div>
        <div class="badge">✨ 콤보: <span id="combo">0</span>x</div>
        <div class="badge">🧤 체온: <span id="temp">100</span>%</div>
        <div class="badge">🧳 가방: 낚시대 <span id="rods">3</span>대</div>
        <div class="right">
          <button id="augerBtn" class="ghost toggle">🌀 아이스오거</button>
          <button id="dayNight" class="ghost">🌞 낮</button>
          <button id="reset" class="ghost">🔄 다시하기</button>
        </div>
      </div>
      <div class="pill">활성 구멍: <span id="activeIdx">-</span> · 숫자키(1–9) 전환 · R: 장착/해제 · ↓: 내리기 · Space: 챔질</div>

      <!-- Gear palette -->
      <div class="gear" id="gear">
        <div class="group">
          <span class="title">릴</span>
          <button data-reel="spinning" class="sel">스피닝</button>
          <button data-reel="baitcasting">베이트</button>
          <button data-reel="handline">견지</button>
        </div>
        <div class="group">
          <span class="title">표현</span>
          <button data-mode="float">찌</button>
          <button data-mode="tip" class="sel">끝보기</button>
        </div>
        <div class="group" style="opacity:.75;font-size:12px;font-weight:700">선택된 조합이 새로 장착(R)될 때 적용</div>
      </div>

      <div class="bottombar">
        <button class="cute" id="dropBtn">⬇️ (활성) 내리기</button>
        <button class="cute" id="liftBtn">⬆️ (활성) 챔질(스페이스)</button>
      </div>
      <div class="toast" id="toast" hidden></div>
    </div>
  </div>

<script>
(function(){
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const dpr = Math.max(1, window.devicePixelRatio||1);
  function fit(){ const w = canvas.clientWidth, h = canvas.clientHeight; canvas.width=Math.round(w*dpr); canvas.height=Math.round(h*dpr); ctx.setTransform(dpr,0,0,dpr,0,0);} new ResizeObserver(fit).observe(canvas); fit();

  const ST = { READY:1, WAIT:2, BITE:3, HOOK:4 };
  let mode = 'FISH'; let time=0; let score=0, combo=0, temp=100; let day=true;

  const holes = []; // per-hole
  /* hole: {x,y,r,ripple, rod:boolean, rig:{reel,mode}, line:{depth,target}, state, biteTimer, hookWindow, fishTarget, bitePhase, biteT, biteAmp, biteDown, frenzyLeft, xJitter} */
  let activeHole = -1; let rodsBagMax=3, rodsBagNow=3; let mouse={x:0.5,y:0.4};

  const fishList=[]; const MAX_FISH=6;

  // UI refs
  const elScore = document.getElementById('score');
  const elCombo = document.getElementById('combo');
  const elTemp  = document.getElementById('temp');
  const elRods  = document.getElementById('rods');
  const elActiveIdx = document.getElementById('activeIdx');
  const toast   = document.getElementById('toast');
  const dropBtn = document.getElementById('dropBtn');
  const liftBtn = document.getElementById('liftBtn');
  const resetBtn= document.getElementById('reset');
  const dayBtn  = document.getElementById('dayNight');
  const augerBtn= document.getElementById('augerBtn');

  // Gear palette state
  const gear = { reel:'spinning', mode:'tip' };
  const gearPanel = document.getElementById('gear');
  gearPanel.addEventListener('click',(e)=>{
    const b = e.target.closest('button'); if(!b) return;
    if(b.dataset.reel){ gear.reel=b.dataset.reel; [...gearPanel.querySelectorAll('button[data-reel]')].forEach(x=>x.classList.toggle('sel', x===b)); }
    if(b.dataset.mode){ gear.mode=b.dataset.mode; [...gearPanel.querySelectorAll('button[data-mode]')].forEach(x=>x.classList.toggle('sel', x===b)); }
  });

  const drills=[]; // auger anim
  function rand(a,b){return a+Math.random()*(b-a)}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
  function lerp(a,b,t){return a+(b-a)*t}

  function spawnFish(){ if(fishList.length>=MAX_FISH) return; const side=Math.random()<.5?-1:1; const y=rand(0.45,0.9); const speed=rand(0.2,0.5)*(Math.random()<.5?1:-1); const scale=rand(0.8,1.3); fishList.push({ x: side<0?-0.2:1.2, y, v: speed*0.0025, s:scale, dir: side<0?1:-1, mood:'cruise', blink:0, tilt:0 }); }
  function pickBiter(){ if(fishList.length===0) return null; const near = fishList.filter(f=>Math.abs(f.y - 0.58) < 0.25); return near.length? near[(Math.random()*near.length)|0] : fishList[(Math.random()*fishList.length)|0]; }

  // Controls
  resetBtn.addEventListener('click', reset);
  dayBtn.addEventListener('click', ()=>{ day=!day; dayBtn.textContent = day? '🌞 낮':'🌙 밤'; });
  augerBtn.addEventListener('click', ()=>{ if(mode==='AUGER'){ mode='FISH'; augerBtn.classList.remove('on'); hideToast(); } else { mode='AUGER'; augerBtn.classList.add('on'); showToast('오거 모드: 원하는 위치로 이동 후 클릭!'); }});
  dropBtn.addEventListener('click', ()=> dropActive());
  liftBtn.addEventListener('click', ()=> hookActive());
  window.addEventListener('keydown', (e)=>{ const n=parseInt(e.key,10); if(n>=1 && n<=holes.length){ setActive(n-1);} if(e.key===' '){ e.preventDefault(); hookActive(); } if(e.key==='r'||e.key==='R'){ toggleRodAtActive(); } if(e.key==='ArrowDown'){ dropActive(); }});
  canvas.addEventListener('pointermove', (e)=>{ const r=canvas.getBoundingClientRect(); mouse.x=(e.clientX-r.left)/r.width; mouse.y=(e.clientY-r.top)/r.height; });
  canvas.addEventListener('pointerdown', (e)=>{ const r=canvas.getBoundingClientRect(); const x=(e.clientX-r.left)/r.width; const y=(e.clientY-r.top)/r.height; if(mode==='AUGER'){ startDrill(x,y); return; } const idx=hitHole(x,y); if(idx!==-1){ setActive(idx); return; } hookActive(); });

  function hitHole(x,y){ for(let i=holes.length-1;i>=0;i--){ const h=holes[i]; const dx=(x-h.x)*canvas.clientWidth, dy=(y-h.y)*canvas.clientHeight; const rx=h.r, ry=h.r*0.62; if((dx*dx)/(rx*rx)+(dy*dy)/(ry*ry)<=1) return i; } return -1; }
  function setActive(i){ activeHole=i; elActiveIdx.textContent=(i+1); showToast(`활성 구멍 ${i+1}`); }

  // Auger / Drill
  function startDrill(x,y){ const minY=0.28; if(y<minY){ showToast('조금 더 아래(얼음)에서 뚫어봐요!'); return; } drills.push({x,y,progress:0,spin:0,shavings:[]}); mode='DRILL'; showToast('드르륵… 구멍 파는 중'); }
  function updateDrills(dt){ for(let i=drills.length-1;i>=0;i--){ const d=drills[i]; d.progress+=dt*0.7; d.spin+=dt*16; if(Math.random()<0.5){ d.shavings.push({x:rand(-6,6),y:rand(-6,6),v:rand(12,28),a:1}); } d.shavings.forEach(s=>{ s.y += s.v*dt; s.a -= dt*0.8;}); d.shavings=d.shavings.filter(s=>s.a>0); if(d.progress>=1){ drills.splice(i,1); const r=68; const h={x:d.x,y:d.y,r, ripple:0, rod:false, rig:null, line:{depth:0,target:20}, state:ST.READY, biteTimer:rand(3.5,7.5), hookWindow:0, fishTarget:null, bitePhase:0, biteT:0, biteAmp:0, biteDown:0, frenzyLeft:0, xJitter:0, tipBaseSag:0}; holes.push(h); if(activeHole===-1) setActive(0); showToast('🕳️ 구멍 완성! (숫자키 전환, R 장착)'); mode='AUGER'; } } }

  // Fishing per hole
  function dropActive(){ if(activeHole===-1) return; const h=holes[activeHole]; if(!h.rod){ showToast('이 구멍에 낚시대를 먼저 장착하세요 (R)'); return; } if(h.state===ST.READY||h.state===ST.WAIT){ h.line.target= (h.rig && h.rig.mode==='float')? 120 : 60; // 끝보기는 줄이 수면 위 짧게 표현
      h.biteTimer=rand(3.5,7.5); resetBite(h); h.state=ST.WAIT; showToast('⬇️ 내렸습니다'); } }
  function hookActive(){ if(activeHole===-1) return; const h=holes[activeHole]; if(!h.rod) return; if(h.state===ST.HOOK){ catchFish(h); } else { miss(h); } }
  function toggleRodAtActive(){ if(activeHole===-1) return; const h=holes[activeHole]; if(h.rod){ h.rod=false; rodsBagNow=clamp(rodsBagNow+1,0,rodsBagMax); showToast('🎒 장비 회수'); } else { if(rodsBagNow<=0){ showToast('가방에 남은 낚시대가 없어요!'); return; } h.rod=true; h.rig={reel:gear.reel, mode:gear.mode}; rodsBagNow--; h.line.target=(h.rig.mode==='float')?120:60; h.state=ST.WAIT; h.biteTimer=rand(3.5,7.5); resetBite(h); showToast(`🪝 ${labelRig(h.rig)} 장착 & 대기`); } elRods.textContent=rodsBagNow; }

  function labelRig(r){ const reel = r.reel==='spinning'?'스피닝': r.reel==='baitcasting'?'베이트':'견지'; const mode=r.mode==='float'?'찌':'끝보기'; return `${reel} · ${mode}`; }
  function resetBite(h){ h.bitePhase=0; h.biteT=0; h.biteAmp=0; h.biteDown=0; h.frenzyLeft=0; h.xJitter=0; }

  function catchFish(h){ const gain=10+Math.floor(combo*1.5); score+=gain; combo+=1; temp=clamp(temp+6,0,100); elScore.textContent=score; elCombo.textContent=combo; elTemp.textContent=Math.round(temp); showToast(`🐟 [${holes.indexOf(h)+1}] 빙어 잡았다! +${gain}`); h.ripple=0.001; h.line.target=(h.rig.mode==='float')?20:40; if(h.fishTarget){ h.fishTarget.mood='cruise'; h.fishTarget.tilt=0.2; setTimeout(()=>{ if(h.fishTarget) h.fishTarget.tilt=0; }, 250);} h.biteTimer=rand(4.0,8.0); h.state=ST.WAIT; resetBite(h); }
  function miss(h){ combo=0; elCombo.textContent=combo; showToast(`😮‍💨 [${holes.indexOf(h)+1}] 놓쳤다…`); h.state=ST.WAIT; h.biteTimer=rand(4.5,8.5); if(h.fishTarget) h.fishTarget.mood='cruise'; resetBite(h); }

  function update(dt){
    time+=dt; temp=Math.max(0,temp-dt*0.9); if(Math.random()<0.02) spawnFish();
    for(const f of fishList){ f.x += f.v*dt*60; f.y += Math.sin((time*0.6 + f.x*7))*0.0008; f.blink = (Math.sin(time*5 + f.x*13) > 0.92)?1:0; if(f.x < -0.25 && f.v<0) f.v*=-1, f.dir=1; if(f.x > 1.25 && f.v>0) f.v*=-1, f.dir=-1; }

    for(const h of holes){ h.line.depth = lerp(h.line.depth, h.line.target, 0.08);
      // 로드 기본 처짐(채비별)
      if(h.rig){
        const targetSag = (h.rig.mode==='tip')
              ? (h.line.target>40 ? 12 : 6)
              : (h.line.target>40 ? 8 : 3); // float: 덜 처짐, 입질 영향 없음
        h.tipBaseSag = lerp(h.tipBaseSag||0, targetSag, 0.08);
      } else {
        h.tipBaseSag = lerp(h.tipBaseSag||0, 0, 0.1);
      }
       if(!h.rod){ h.ripple=Math.max(0,(h.ripple||0)-dt*0.6); continue; }
      if(h.state===ST.WAIT){ h.biteTimer -= dt; if(h.biteTimer<=0){ h.fishTarget = pickBiter(); h.ripple=0.001; h.bitePhase=1; h.biteT=0; h.biteAmp=6; h.state=ST.BITE; }}
      if(h.state===ST.BITE || h.state===ST.HOOK){ h.ripple += dt*(h.state===ST.HOOK?1.8:1.5); if(h.ripple>1.2) h.ripple=0; h.biteT += dt; const tok=(amp,t)=> Math.max(0, amp*Math.exp(-t*14)*Math.sin(t*40)); h.biteDown = tok(h.biteAmp, h.biteT); const targetJit=(h.bitePhase===3?3:1.2); h.xJitter = lerp(h.xJitter||0, Math.sin(time*2.2)*targetJit, 0.15);
        if(h.bitePhase===1 && h.biteT>0.18){ h.bitePhase=2; h.biteT=0; h.biteAmp=10; }
        else if(h.bitePhase===2 && h.biteT>0.22){ h.state=ST.HOOK; h.hookWindow = 0.8 + Math.random()*0.6; if(Math.random()<0.5){ h.bitePhase=3; h.biteT=0; h.biteAmp=8; h.frenzyLeft = 3 + (Math.random()*4|0);} else { h.bitePhase=0; } }
        else if(h.bitePhase===3){ if(h.biteT>0.14){ h.biteT=0; h.frenzyLeft--; h.biteAmp = 7 + Math.random()*3; } if(h.frenzyLeft<=0){ h.bitePhase=0; } h.hookWindow -= dt; if(h.hookWindow<=0){ miss(h); } }
        else if(h.state===ST.HOOK && h.bitePhase===0){ h.hookWindow -= dt; if(h.hookWindow<=0){ miss(h); } }
      }
      if(h.state!==ST.BITE && h.state!==ST.HOOK){ h.ripple=Math.max(0,(h.ripple||0)-dt*0.8); h.biteDown=0; h.xJitter=lerp(h.xJitter||0,0,0.1); }
    }

    if(mode==='DRILL') updateDrills(dt);
    elRods.textContent=rodsBagNow;
  }

  // ---- RENDER ----
  function drawBackground(){ const {width:W,height:H} = canvas; const g=ctx.createLinearGradient(0,0,0,H); if(day){ g.addColorStop(0,'#eaf7ff'); g.addColorStop(1,'#ffffff'); } else { g.addColorStop(0,'#0b1736'); g.addColorStop(1,'#12214d'); } ctx.fillStyle=g; ctx.fillRect(0,0,W,H); const iceTop=H*0.28; ctx.fillStyle = day? '#dff3ff' : '#1a2b4d'; ctx.fillRect(0, iceTop, W, H-iceTop); ctx.globalAlpha = day?0.22:0.15; ctx.fillStyle='#ffffff'; for(let i=0;i<60;i++){ const x=(i*73+(time*22)%73)%W; const y= iceTop-10-(i*11%30); ctx.fillRect(x,y,3,3);} ctx.globalAlpha=1; }

  function drawHole(h,i){ const W=canvas.width,H=canvas.height; const cx=W*h.x, cy=H*h.y, r=h.r; ctx.save(); ctx.fillStyle= day?'#9bd3ff':'#0c2a47'; ctx.beginPath(); ctx.ellipse(cx, cy, r*1.15, r*0.8, 0,0,Math.PI*2); ctx.fill(); const g=ctx.createLinearGradient(0,cy-r,0,cy+r); g.addColorStop(0, day?'#bfe6ff':'#0c3f6b'); g.addColorStop(1, day?'#8fd2ff':'#0a2d4d'); ctx.fillStyle=g; ctx.beginPath(); ctx.ellipse(cx, cy, r, r*0.62, 0,0,Math.PI*2); ctx.fill(); ctx.lineWidth=8; ctx.strokeStyle= day?'#e8f7ff':'#224a73'; ctx.stroke(); if(h.ripple>0){ for(let k=0;k<3;k++){ const t=(h.ripple*1.2 - k*0.25); if(t<0) continue; ctx.globalAlpha=Math.max(0,1-t)*0.6; ctx.lineWidth=2; ctx.strokeStyle= day?'#ffffff':'#d0ecff'; ctx.beginPath(); ctx.ellipse(cx, cy+2, r*(1+t*0.6), r*0.62*(1+t*0.6), 0,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; }} if(i===activeHole){ ctx.strokeStyle='#ff8fb1'; ctx.lineWidth=2; ctx.setLineDash([6,6]); ctx.beginPath(); ctx.ellipse(cx, cy, r*1.25, r*0.9, 0,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([]); } ctx.fillStyle='#0008'; ctx.font='bold 12px system-ui'; ctx.textAlign='center'; const rigLbl = h.rig? (h.rig.mode==='float'?'찌':'끝') : ''; ctx.fillText(`${i+1}${h.rod?' ':''} ${rigLbl}`, cx, cy + r*0.85); ctx.restore(); }

  function drawRigFor(h){ if(!h.rod) return; if(!h.rig||h.rig.mode==='float') return drawFloatFor(h); else return drawTipFor(h); }

  // 찌 모드 (기존)
  function drawFloatFor(h){
    // "끝보기 스타일 + 찌" : 로드는 기본 처짐만, 찌만 입질에 반응
    const W=canvas.width,H=canvas.height; const cx=W*h.x, cy=H*h.y;
    const baseY = H*0.22; const bx = cx-162, by = baseY+10; const L=150;

    ctx.save();
    // 거치대
    ctx.lineWidth=3; ctx.strokeStyle= day?'#9aa3ad':'#6f7a86';
    ctx.beginPath();
    ctx.moveTo(bx, by+6); ctx.lineTo(bx+18, by-18); ctx.lineTo(bx+36, by+6);
    ctx.moveTo(bx, by+6); ctx.lineTo(bx, by+26); ctx.moveTo(bx+36, by+6); ctx.lineTo(bx+36, by+26);
    ctx.stroke();
    // 릴(간단 원형)
    ctx.beginPath(); ctx.lineWidth=4; ctx.strokeStyle= day?'#3b3e44':'#22252b'; ctx.arc(bx+20, by-22, 9, 0, Math.PI*2); ctx.stroke();

    // 로드 곡선 (기본 처짐만 적용: h.tipBaseSag)
    const sag = (h.tipBaseSag||0);
    const segs=14, pts=[];
    for(let i=0;i<=segs;i++){
      const t=i/segs;
      const px = bx + 20 + t*L;
      const baseSlope = by + 6 + t*10;
      const bend = sag * (t*t) * (0.35 + 0.65*t);
      const py = baseSlope + bend; pts.push({x:px,y:py});
    }
    for(let i=0;i<segs;i++){ const p=pts[i], q=pts[i+1]; const t=i/segs; ctx.lineWidth=7*(1-t*0.75); ctx.strokeStyle= day?'#3b2b1a':'#2e2319'; ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(q.x,q.y); ctx.stroke(); }
    for(let i=Math.floor(segs*0.7); i<segs; i++){ const p=pts[i], q=pts[i+1]; ctx.lineWidth=3; ctx.strokeStyle = h.rig && h.rig.reel==='baitcasting'? '#ffb26b' : (h.rig && h.rig.reel==='handline'? '#7bf0a3' : '#7bb2ff'); ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(q.x,q.y); ctx.stroke(); }

    // 팁 좌표
    const tip = pts[pts.length-1];

    // 직선 줄: 팁 → 얼음구멍 타원 경계
    const rx=(h.r||60), ry=rx*0.22; // 타원 반경
    const ux=cx-tip.x, uy=cy-tip.y; const ulen=Math.hypot(ux,uy)||1; const vx=ux/ulen, vy=uy/ulen;
    const dx=tip.x-cx, dy=tip.y-cy;
    const A=(vx*vx)/(rx*rx)+(vy*vy)/(ry*ry);
    const B=2*((dx*vx)/(rx*rx)+(dy*vy)/(ry*ry));
    const C=(dx*dx)/(rx*rx)+(dy*dy)/(ry*ry)-1;
    const D=Math.max(0,B*B-4*A*C);
    let s=(-B+Math.sqrt(D))/(2*A); if(!(s>0)) s=(-B-Math.sqrt(D))/(2*A);
    const hx=tip.x+vx*s, hy=tip.y+vy*s; // 경계 접점

    // 줄 그리기
    ctx.lineWidth=1.8; ctx.strokeStyle='rgba(255,255,255,0.9)';
    ctx.beginPath(); ctx.moveTo(tip.x, tip.y); ctx.lineTo(hx, hy); ctx.stroke();

    // 찌: 경계 위치에 안착 + 입질만 반응 (아래로 톡)
    const floatDip = (h.biteDown||0); // 입질만 적용
    const bX = hx, bY = hy + floatDip - 10;
    ctx.translate(bX,bY);
    ctx.fillStyle='#ff6f91';
    ctx.beginPath(); ctx.ellipse(0,0,10,14,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff3'; ctx.fillRect(-2,-14,4,6);
    ctx.restore();
  }

  // 끝보기 모드
  function drawTipFor(h){
    const W=canvas.width,H=canvas.height; const cx=W*h.x, cy=H*h.y;
    const baseY = H*0.22;
    const bx = cx+152, by = baseY+10; // 베이스(그립) 위치
    const L = 150; // 로드 유효 길이

    // --- 삼각대/거치대(간략) ---
    ctx.save();
    ctx.lineWidth=3; ctx.strokeStyle= day?'#9aa3ad':'#6f7a86';
    ctx.beginPath();
    ctx.moveTo(bx, by+6); ctx.lineTo(bx+18, by-18); ctx.lineTo(bx+36, by+6); // 상단 브릿지
    ctx.moveTo(bx, by+6); ctx.lineTo(bx, by+26); // 다리
    ctx.moveTo(bx+36, by+6); ctx.lineTo(bx+36, by+26);
    ctx.stroke();
    // 리얼한 릴 느낌 (간단 원형)
    ctx.beginPath(); ctx.lineWidth=4; ctx.strokeStyle= day?'#3b3e44':'#22252b';
    ctx.arc(bx+20, by-22, 9, 0, Math.PI*2); ctx.stroke();

    // --- 로드 곡선 계산 (끝보기용: 부드러운 텐션 + 팁에서 크게 굽힘) ---
    const sag = (h.tipBaseSag||0) + (h.biteDown||0); // 기본 처짐 + 입질 추가
    const segs = 14; // 세그먼트 분할로 굵기 변화 표현

    // 로드의 기준선(살짝 전방 기울기) + 빔 굴곡 근사: y(t)=a*t^2*(0.35+0.65*t)
    const pts=[];
    for(let i=0;i<=segs;i++){
      const t = i/segs; // 0..1
      const px = bx + 20 - t*L; // 오른쪽으로 뻗음
      const baseSlope = by + 6 + t*10; // 기울기
      const bend = sag * (t*t) * (0.35 + 0.65*t); // 팁에 갈수록 증가
      const py = baseSlope + bend;
      pts.push({x:px, y:py});
    }

    // 로드 바디: 세그먼트별 굵기 테이퍼링
    for(let i=0;i<segs;i++){
      const p=pts[i], q=pts[i+1];
      const t=i/segs; // 굵기 보간 (버트 두껍고 팁 얇게)
      ctx.lineWidth = 7*(1-t*0.75);
      ctx.strokeStyle = day?'#3b2b1a':'#2e2319';
      ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(q.x,q.y); ctx.stroke();
    }

    // 초릿대 강조 라인(밝은 색) — 마지막 30%만
    for(let i=Math.floor(segs*0.7); i<segs; i++){
      const p=pts[i], q=pts[i+1];
      ctx.lineWidth = 3;
      ctx.strokeStyle = h.rig && h.rig.reel==='baitcasting'? '#ffb26b' : (h.rig && h.rig.reel==='handline'? '#7bf0a3' : '#7bb2ff');
      ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(q.x,q.y); ctx.stroke();
    }

    // 가이드링(팁 쪽 작은 링들)
    const tipIdx = pts.length-1; const tip = pts[tipIdx];
    const guides = [0.45,0.6,0.72,0.84,0.92,0.98];
    ctx.fillStyle = day?'#ffd66b':'#ffd36b';
    guides.forEach(t=>{
      const i = Math.floor(t*segs); const p=pts[i];
      ctx.beginPath(); ctx.arc(p.x, p.y, 2.2, 0, Math.PI*2); ctx.fill();
    });

    // 낚싯줄: 팁에서 구멍까지 곡선 (팁 처짐에 따라 살짝 더 아래로)
    ctx.lineWidth=1.6; ctx.strokeStyle='rgba(255,255,255,0.8)';
    ctx.beginPath();
    ctx.moveTo(tip.x, tip.y);
    ctx.quadraticCurveTo(cx+8, cy-60 + sag*0.18, cx, cy);
    ctx.stroke();

    // 팁 하이라이트 점
    ctx.beginPath(); ctx.arc(tip.x, tip.y, 3.5, 0, Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.85)'; ctx.fill();
    ctx.restore();
  }

  function drawAugerCursor(){ if(mode!=='AUGER') return; const W=canvas.width,H=canvas.height; const cx=W*mouse.x, cy=H*mouse.y; const r=70; ctx.save(); ctx.globalAlpha=0.5; ctx.fillStyle='#0004'; ctx.fillRect(0,0,W,H); ctx.globalCompositeOperation='destination-out'; let grd=ctx.createRadialGradient(cx,cy,10,cx,cy,r); grd.addColorStop(0,'rgba(0,0,0,1)'); grd.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.restore(); ctx.save(); ctx.strokeStyle='#2b5'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(cx,cy,r*0.9,0,Math.PI*2); ctx.stroke(); ctx.lineWidth=2; ctx.strokeStyle='#0a0'; ctx.beginPath(); ctx.arc(cx,cy,r*0.5, time*2, time*2+Math.PI*1.2); ctx.stroke(); ctx.restore(); }
  function drawDrills(){ for(const d of drills){ const W=canvas.width,H=canvas.height; const cx=W*d.x, cy=H*d.y; const r= 70*(0.9+0.1*Math.sin(time*10)); ctx.save(); ctx.translate(cx,cy); ctx.rotate(d.spin); ctx.fillStyle='#444'; for(let i=0;i<3;i++){ ctx.rotate((Math.PI*2)/3); ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(22,6); ctx.lineTo(6,22); ctx.closePath(); ctx.fill(); } ctx.restore(); ctx.save(); ctx.translate(cx,cy); for(const s of d.shavings){ ctx.globalAlpha=Math.max(0,s.a); ctx.beginPath(); ctx.arc(s.x, s.y, 2.2, 0, Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); } ctx.restore(); ctx.save(); ctx.strokeStyle='#ff8fb1'; ctx.lineWidth=4; ctx.beginPath(); ctx.arc(cx,cy,40, -Math.PI/2, -Math.PI/2 + d.progress*2*Math.PI); ctx.stroke(); ctx.restore(); } }

  function render(){ ctx.clearRect(0,0,canvas.width,canvas.height); drawBackground(); holes.forEach((h,i)=> drawHole(h,i)); if(activeHole!==-1){ const h=holes[activeHole]; const cx=canvas.width*h.x, cy=canvas.height*h.y, rx=h.r, ry=h.r*0.62; ctx.save(); ctx.beginPath(); ctx.ellipse(cx, cy, rx, ry, 0,0,Math.PI*2); ctx.clip(); ctx.fillStyle = day? 'rgba(120,190,255,0.18)' : 'rgba(30,80,140,0.28)'; ctx.fillRect(0, cy-ry, canvas.width, ry*2); for(const f of fishList){ const W=canvas.width,H=canvas.height; const x=f.x*W, y=f.y*H; const dir=f.dir; ctx.save(); ctx.translate(x,y); ctx.scale(dir*f.s, f.s); ctx.rotate(f.tilt||0); ctx.fillStyle = day? '#c8f2ff':'#9fd1ff'; roundRect(-22,-8,44,18,9); ctx.fill(); ctx.beginPath(); ctx.moveTo(-26,0); ctx.quadraticCurveTo(-40,-14,-34,0); ctx.quadraticCurveTo(-40,14,-26,0); ctx.fillStyle= day?'#a8e6ff':'#86bfff'; ctx.fill(); ctx.fillStyle='#ffd5e5'; ctx.beginPath(); ctx.arc(6,2,4,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#233'; if(f.blink>0){ ctx.fillRect(10,-1,6,2);} else { ctx.beginPath(); ctx.arc(12,-1,3,0,Math.PI*2); ctx.fill(); } ctx.fillStyle='#fff8'; ctx.fillRect(6,-4,3,3); ctx.fillStyle='#233'; if(f.mood==='bite') ctx.fillRect(20,-2,4,4); else ctx.fillRect(20,-1,3,2); ctx.restore(); } ctx.restore(); } holes.forEach(h=> drawRigFor(h)); drawDrills(); drawAugerCursor(); elScore.textContent=score; elCombo.textContent=combo; elTemp.textContent=Math.round(temp); }

  function roundRect(x,y,w,h,r){ const rr=Math.min(r,Math.abs(w)/2,Math.abs(h)/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); }
  function showToast(txt){ toast.hidden=false; toast.textContent=txt; clearTimeout(showToast._t); showToast._t=setTimeout(()=> toast.hidden=true, 1200); }
  function hideToast(){ toast.hidden=true; }

  function reset(){ score=0; combo=0; temp=100; rodsBagNow=rodsBagMax; time=0; holes.length=0; activeHole=-1; drills.length=0; fishList.length=0; for(let i=0;i<4;i++) spawnFish(); elRods.textContent=rodsBagNow; mode='FISH'; augerBtn.classList.remove('on'); showToast('오거로 구멍을 만들고(R) 장착해 보세요!'); }

  reset();
  let last=performance.now();
  (function loop(now){ const dt=Math.min(0.033,(now-last)/1000); last=now; update(dt); render(); requestAnimationFrame(loop); })(performance.now());
})();
</script>
</body>
</html>

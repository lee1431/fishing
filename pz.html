<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<title>Swipe Match-3 (Crush + Specials)</title>
<style>
  :root{ --cell:56px; --gap:6px; }
  body{
    margin:0; background:#0b0f14; color:#fff;
    font-family:system-ui,-apple-system,Segoe UI,Roboto;
    display:flex; justify-content:center; align-items:center; min-height:100vh;
    padding:14px;
  }
  #wrap{ width:calc(var(--cell)*9 + var(--gap)*8); }
  #topbar{
    display:flex; justify-content:space-between; align-items:center;
    margin-bottom:10px; gap:10px;
  }
  .pill{
    padding:10px 12px; border-radius:14px;
    background:rgba(255,255,255,.05);
    border:1px solid rgba(255,255,255,.10);
    font-weight:800;
  }
  #board{
    position:relative;
    width:100%;
    height:calc(var(--cell)*9 + var(--gap)*8);
    background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.10);
    border-radius:20px;
    touch-action:none; user-select:none;
    overflow:hidden;
  }

  .tile{
    position:absolute;
    width:var(--cell); height:var(--cell);
    border-radius:14px;
    display:flex; align-items:center; justify-content:center;
    font-size:22px; font-weight:900;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.12);
    transition: transform 180ms cubic-bezier(.25,.8,.25,1);
    will-change: transform;
  }
  .tile.red{background:linear-gradient(#ff4b4b,#c3152d)}
  .tile.blue{background:linear-gradient(#42a5ff,#1762d6)}
  .tile.green{background:linear-gradient(#35e28a,#0e9c61)}
  .tile.yellow{background:linear-gradient(#ffd84c,#e2a600)}
  .tile.purple{background:linear-gradient(#b57cff,#6b2bff)}

  /* íŠ¹ìˆ˜ í‘œì‹œ(ì‘ì€ ë°°ì§€) */
  .badge{
    position:absolute; right:6px; top:6px;
    font-size:12px; font-weight:900;
    padding:4px 7px; border-radius:999px;
    background:rgba(0,0,0,.35);
    border:1px solid rgba(255,255,255,.14);
    pointer-events:none;
  }

  /* í„°ì§ ì• ë‹ˆë©”ì´ì…˜ */
  .popping{
    transition: transform 140ms ease, opacity 140ms ease !important;
    opacity:0;
    transform: translate(var(--tx), var(--ty)) scale(.2) !important;
  }

  /* ì‚´ì§ ê°•ì¡°(ìŠ¤ì™‘ ì¤‘) */
  .pulse{
    animation:pulse .25s ease;
  }
  @keyframes pulse{
    0%{filter:brightness(1)}
    50%{filter:brightness(1.12)}
    100%{filter:brightness(1)}
  }

  button{
    border:1px solid rgba(255,255,255,.14);
    background:rgba(255,255,255,.06);
    color:#fff; border-radius:12px;
    padding:10px 12px; font-weight:800;
  }
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <div class="pill">ì´ë™: <span id="moves">âˆ</span></div>
    <button id="restart">ë¦¬ì…‹</button>
  </div>
  <div id="board"></div>
</div>

<script>
(() => {
  const W=9, H=9;
  const TYPES=["red","blue","green","yellow","purple"];
  const board = document.getElementById("board");
  const movesEl = document.getElementById("moves");
  const restartBtn = document.getElementById("restart");

  const cell = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'));
  const gap  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'));

  // ì´ë™ ì œí•œ ì›í•˜ë©´ ìˆ«ì ë„£ê¸°
  let moves = Infinity;

  // grid[y][x] = { type, special, id }
  let grid = [];
  let tilesById = new Map();
  let busy = false;

  const Special = {
    NONE: null,
    LINE_H: "lineH", // ê°€ë¡œ í•œì¤„
    LINE_V: "lineV", // ì„¸ë¡œ í•œì¤„
    PLUS: "plus",    // + ëª¨ì–‘
    BOMB9: "bomb9"   // 3x3 (9ì¹¸)
  };

  function icon(type){
    return {red:"â˜•", blue:"ğŸ’§", green:"ğŸ", yellow:"ğŸ ", purple:"ğŸ’"}[type];
  }
  function badgeText(s){
    return {
      lineH:"â€”",
      lineV:"|",
      plus:"+",
      bomb9:"9"
    }[s] || "";
  }

  function pos(x,y){
    return { x: x*(cell+gap), y: y*(cell+gap) };
  }
  function key(x,y){ return `${x},${y}`; }
  function inb(x,y){ return x>=0 && y>=0 && x<W && y<H; }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
  function setMoves(){
    movesEl.textContent = (moves===Infinity ? "âˆ" : String(moves));
  }

  function makeId(){
    return Math.random().toString(36).slice(2) + Date.now().toString(36);
  }

  function createTileEl(cellObj){
    const el = document.createElement("div");
    el.className = `tile ${cellObj.type}`;
    el.textContent = icon(cellObj.type);
    el.dataset.id = cellObj.id;

    if(cellObj.special){
      const b = document.createElement("div");
      b.className = "badge";
      b.textContent = badgeText(cellObj.special);
      el.appendChild(b);
    }
    board.appendChild(el);
    return el;
  }

  function updateBadge(el, special){
    // remove old badge
    const old = el.querySelector(".badge");
    if(old) old.remove();
    if(special){
      const b = document.createElement("div");
      b.className="badge";
      b.textContent = badgeText(special);
      el.appendChild(b);
    }
  }

  function moveTileEl(el, x, y){
    const p = pos(x,y);
    el.style.setProperty("--tx", p.x+"px");
    el.style.setProperty("--ty", p.y+"px");
    el.style.transform = `translate(${p.x}px,${p.y}px)`;
  }

  function init(){
    busy=false;
    tilesById.clear();
    board.innerHTML = "";
    setMoves();

    grid = Array.from({length:H}, ()=>Array.from({length:W}, ()=>null));

    // ì´ˆê¸° ë³´ë“œ ìƒì„± (ì´ˆê¸° 3ë§¤ì¹˜ ìµœëŒ€í•œ íšŒí”¼)
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        let type, guard=0;
        do{
          type = TYPES[(Math.random()*TYPES.length)|0];
          guard++;
        }while(guard<50 && wouldMatchAt(x,y,type));

        const cellObj = { type, special: Special.NONE, id: makeId() };
        grid[y][x]=cellObj;
        const el = createTileEl(cellObj);
        tilesById.set(cellObj.id, el);
        moveTileEl(el, x, y);
      }
    }
  }

  function wouldMatchAt(x,y,type){
    // left-left
    if(x>=2 && grid[y][x-1] && grid[y][x-2]
      && grid[y][x-1].type===type && grid[y][x-2].type===type) return true;
    // up-up
    if(y>=2 && grid[y-1][x] && grid[y-2][x]
      && grid[y-1][x].type===type && grid[y-2][x].type===type) return true;
    return false;
  }

  // ---------- Touch Swipe ----------
  let touchStart=null;
  let startCell=null;

  board.addEventListener("touchstart", (e) => {
    if(busy) return;
    const t = e.touches[0];
    touchStart={x:t.clientX,y:t.clientY};
    startCell = cellFromPoint(t.clientX,t.clientY);
  }, {passive:true});

  board.addEventListener("touchend", async (e) => {
    if(busy) return;
    if(!touchStart || !startCell) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;

    let dir=null;
    if(Math.abs(dx) > Math.abs(dy)){
      if(dx>28) dir="right";
      if(dx<-28) dir="left";
    }else{
      if(dy>28) dir="down";
      if(dy<-28) dir="up";
    }

    if(dir){
      const {x,y} = startCell;
      const nx = x + ({left:-1,right:1,up:0,down:0}[dir]);
      const ny = y + ({left:0,right:0,up:-1,down:1}[dir]);
      if(inb(nx,ny)){
        await trySwapAndResolve(x,y,nx,ny);
      }
    }

    touchStart=null;
    startCell=null;
  }, {passive:true});

  function cellFromPoint(px,py){
    const rect = board.getBoundingClientRect();
    const lx = px - rect.left;
    const ly = py - rect.top;
    const x = Math.floor(lx / (cell+gap));
    const y = Math.floor(ly / (cell+gap));
    if(!inb(x,y)) return null;
    return {x,y};
  }

  async function trySwapAndResolve(x1,y1,x2,y2){
    if(moves!==Infinity){
      if(moves<=0) return;
      moves--; setMoves();
    }

    busy=true;
    await animateSwap(x1,y1,x2,y2);

    // ìŠ¤ì™‘ í›„ ë§¤ì¹˜ ì°¾ê¸°
    let info = findMatchesInfo();

    if(info.matched.size===0){
      // ë§¤ì¹˜ ì—†ìœ¼ë©´ ë˜ëŒë¦¼
      await animateSwap(x1,y1,x2,y2);
      busy=false;
      return;
    }

    // ë§¤ì¹˜ê°€ ìˆìœ¼ë©´ ì—°ì‡„ ì²˜ë¦¬
    while(true){
      info = findMatchesInfo();
      if(info.matched.size===0) break;

      // íŠ¹ìˆ˜ ìƒì„±(ë§¤ì¹˜ ë©ì–´ë¦¬ ë¶„ì„) + ì œê±°/ë°œë™
      await crushWithSpecials(info, {x1,y1,x2,y2});

      await applyGravity();
      await refill();
    }

    busy=false;
  }

  async function animateSwap(x1,y1,x2,y2){
    const a = grid[y1][x1];
    const b = grid[y2][x2];

    // swap in grid
    grid[y1][x1] = b;
    grid[y2][x2] = a;

    // move elements
    const elA = tilesById.get(a.id);
    const elB = tilesById.get(b.id);
    elA.classList.add("pulse");
    elB.classList.add("pulse");

    moveTileEl(elA, x2, y2);
    moveTileEl(elB, x1, y1);

    await sleep(190);
    elA.classList.remove("pulse");
    elB.classList.remove("pulse");
  }

  // ---------- Match Detect + Components ----------
  function findMatchesInfo(){
    const matched = new Set(); // "x,y"
    const horizRuns = []; // {y, x0, len}
    const vertRuns  = []; // {x, y0, len}

    // horizontal runs
    for(let y=0;y<H;y++){
      let runType=null, runStart=0, runLen=0;
      for(let x=0;x<=W;x++){
        const c = (x<W) ? grid[y][x] : null;
        const t = c ? c.type : null;

        if(x===0){
          runType=t; runStart=0; runLen=1;
        }else if(x<W && t===runType){
          runLen++;
        }else{
          if(runType && runLen>=3){
            horizRuns.push({y, x0:runStart, len:runLen});
            for(let k=runStart;k<runStart+runLen;k++) matched.add(key(k,y));
          }
          runType=t;
          runStart=x;
          runLen=1;
        }
      }
    }

    // vertical runs
    for(let x=0;x<W;x++){
      let runType=null, runStart=0, runLen=0;
      for(let y=0;y<=H;y++){
        const c = (y<H) ? grid[y][x] : null;
        const t = c ? c.type : null;

        if(y===0){
          runType=t; runStart=0; runLen=1;
        }else if(y<H && t===runType){
          runLen++;
        }else{
          if(runType && runLen>=3){
            vertRuns.push({x, y0:runStart, len:runLen});
            for(let k=runStart;k<runStart+runLen;k++) matched.add(key(x,k));
          }
          runType=t;
          runStart=y;
          runLen=1;
        }
      }
    }

    // connected components on matched cells (4-neighbor)
    const comps = [];
    const seen = new Set();
    for(const k of matched){
      if(seen.has(k)) continue;
      const [sx,sy]=k.split(",").map(Number);
      const q=[[sx,sy]];
      const cells=[];
      seen.add(k);
      while(q.length){
        const [x,y]=q.pop();
        cells.push([x,y]);
        for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
          const nx=x+dx, ny=y+dy;
          const kk=key(nx,ny);
          if(inb(nx,ny) && matched.has(kk) && !seen.has(kk)){
            seen.add(kk);
            q.push([nx,ny]);
          }
        }
      }
      comps.push(cells);
    }

    return { matched, horizRuns, vertRuns, comps };
  }

  function has2x2Square(cellsSet){
    // cellsSet: Set("x,y")
    for(const k of cellsSet){
      const [x,y]=k.split(",").map(Number);
      if(inb(x+1,y+1)){
        const a = key(x,y), b=key(x+1,y), c=key(x,y+1), d=key(x+1,y+1);
        if(cellsSet.has(a)&&cellsSet.has(b)&&cellsSet.has(c)&&cellsSet.has(d)){
          return [x,y]; // top-left of square
        }
      }
    }
    return null;
  }

  function pickPivot(pivotPrefer, cells){
    // pivotPrefer: usually second swapped cell
    if(pivotPrefer){
      const kk = key(pivotPrefer.x, pivotPrefer.y);
      for(const [x,y] of cells){
        if(key(x,y)===kk) return {x,y};
      }
    }
    // else center-ish
    let sx=0, sy=0;
    for(const [x,y] of cells){ sx+=x; sy+=y; }
    const cx = Math.round(sx/cells.length);
    const cy = Math.round(sy/cells.length);
    // ê°€ì¥ ê°€ê¹Œìš´ ì…€
    let best=cells[0], bestD=1e9;
    for(const [x,y] of cells){
      const d = (x-cx)**2 + (y-cy)**2;
      if(d<bestD){ bestD=d; best=[x,y]; }
    }
    return {x:best[0], y:best[1]};
  }

  // ---------- Crush + Specials ----------
  async function crushWithSpecials(info, swapPos){
    // ê° ì»´í¬ë„ŒíŠ¸ë§ˆë‹¤ "íŠ¹ìˆ˜ ìƒì„±" ê²°ì • í›„ ì œê±° ì²˜ë¦¬
    // ì œê±°ë  ì…€ set
    const toRemove = new Set();
    // ë°œë™ë  íŠ¹ìˆ˜: [{x,y,special}]
    const toTrigger = [];

    for(const cells of info.comps){
      const cellsSet = new Set(cells.map(([x,y])=>key(x,y)));

      // íŠ¹ìˆ˜ ìƒì„± ê·œì¹™ ìš°ì„ ìˆœìœ„: 6+ -> bomb9, else 2x2 -> plus, else 4 line -> line
      let createSpecial = null;
      let createAt = null;

      if(cells.length >= 6){
        createSpecial = Special.BOMB9; // 3x3
        createAt = pickPivot({x:swapPos.x2,y:swapPos.y2}, cells);
      }else{
        // 2x2 square?
        const sq = has2x2Square(cellsSet);
        if(sq){
          createSpecial = Special.PLUS;
          // square ê¸°ì¤€ pivot: ìŠ¤ì™‘ ìœ„ì¹˜ê°€ í¬í•¨ë˜ë©´ ê·¸ìª½, ì•„ë‹ˆë©´ squareì˜ í•œ ì¹¸
          createAt = pickPivot({x:swapPos.x2,y:swapPos.y2}, cells);
        }else{
          // line of 4 in this component?
          // ì»´í¬ë„ŒíŠ¸ ë‚´ë¶€ì˜ ê°€ë¡œ/ì„¸ë¡œ run ì¤‘ len>=4ì¸ ê²ƒì´ ìˆìœ¼ë©´ ìƒì„±
          let foundLine=null;
          for(const r of info.horizRuns){
            if(r.len>=4){
              // runì˜ ì…€ë“¤ ì¤‘ ì»´í¬ë„ŒíŠ¸ì— 4ê°œ ì´ìƒ í¬í•¨ë˜ëŠ”ì§€
              let cnt=0;
              for(let k=r.x0;k<r.x0+r.len;k++){
                if(cellsSet.has(key(k,r.y))) cnt++;
              }
              if(cnt>=4){ foundLine={dir:"H", r}; break; }
            }
          }
          if(!foundLine){
            for(const r of info.vertRuns){
              if(r.len>=4){
                let cnt=0;
                for(let k=r.y0;k<r.y0+r.len;k++){
                  if(cellsSet.has(key(r.x,k))) cnt++;
                }
                if(cnt>=4){ foundLine={dir:"V", r}; break; }
              }
            }
          }
          if(foundLine){
            createSpecial = (foundLine.dir==="H") ? Special.LINE_H : Special.LINE_V;
            createAt = pickPivot({x:swapPos.x2,y:swapPos.y2}, cells);
          }
        }
      }

      // ì œê±°í•  ì…€ë“¤: ê¸°ë³¸ì€ ì»´í¬ë„ŒíŠ¸ ì „ì²´ ì œê±°
      for(const k of cellsSet) toRemove.add(k);

      // íŠ¹ìˆ˜ ìƒì„±ì´ ìˆìœ¼ë©´: ìƒì„± ìœ„ì¹˜ëŠ” "ì œê±°ì—ì„œ ì œì™¸"í•˜ê³  íŠ¹ìˆ˜ë¡œ ë³€í™˜
      if(createSpecial && createAt){
        const kk = key(createAt.x, createAt.y);
        // pivotì´ ì»´í¬ë„ŒíŠ¸ì— ì—†ìœ¼ë©´ ê·¸ëƒ¥ ì²« ì…€ ì‚¬ìš©
        if(!cellsSet.has(kk)){
          const [fx,fy]=cells[0];
          createAt={x:fx,y:fy};
        }
        const pivotKey = key(createAt.x, createAt.y);
        // pivotì€ ì œê±°í•˜ì§€ ì•Šê³  specialë¡œ ë‚¨ê¹€
        toRemove.delete(pivotKey);

        const cellObj = grid[createAt.y][createAt.x];
        cellObj.special = createSpecial;
        const el = tilesById.get(cellObj.id);
        updateBadge(el, createSpecial);
      }
    }

    // ì œê±° ì¤‘ íŠ¹ìˆ˜ íƒ€ì¼ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ "ë°œë™" ì²˜ë¦¬
    // (ë°œë™: ì œê±° ëŒ€ìƒì— ë“¤ì–´ê°„ íŠ¹ìˆ˜ íƒ€ì¼ë“¤ì€ íš¨ê³¼ ë²”ìœ„ë¥¼ toRemoveì— ì¶”ê°€)
    // ë¨¼ì € ìŠ¤ìº”
    for(const k of Array.from(toRemove)){
      const [x,y]=k.split(",").map(Number);
      const c = grid[y][x];
      if(!c) continue;
      if(c.special){
        toTrigger.push({x,y,special:c.special});
      }
    }
    // ë°œë™ ë²”ìœ„ ì¶”ê°€
    for(const t of toTrigger){
      const extra = effectCells(t.x, t.y, t.special);
      for(const kk of extra) toRemove.add(kk);
    }

    // ì‹¤ì œ ì œê±° ì• ë‹ˆë©”ì´ì…˜
    await popCells(toRemove);
  }

  function effectCells(x,y,special){
    const s = new Set();
    if(special===Special.LINE_H){
      for(let xx=0; xx<W; xx++) s.add(key(xx,y));
    }else if(special===Special.LINE_V){
      for(let yy=0; yy<H; yy++) s.add(key(x,yy));
    }else if(special===Special.PLUS){
      for(let xx=0; xx<W; xx++) s.add(key(xx,y));
      for(let yy=0; yy<H; yy++) s.add(key(x,yy));
    }else if(special===Special.BOMB9){
      for(let yy=y-1; yy<=y+1; yy++){
        for(let xx=x-1; xx<=x+1; xx++){
          if(inb(xx,yy)) s.add(key(xx,yy));
        }
      }
    }
    return s;
  }

  async function popCells(keysSet){
    // pop animation
    const els=[];
    for(const k of keysSet){
      const [x,y]=k.split(",").map(Number);
      if(!inb(x,y)) continue;
      const c = grid[y][x];
      if(!c) continue;
      const el = tilesById.get(c.id);
      if(el){
        els.push(el);
        el.classList.add("popping");
      }
      // grid clear
      grid[y][x]=null;
    }
    await sleep(150);

    // remove elements
    for(const el of els){
      const id = el.dataset.id;
      tilesById.delete(id);
      el.remove();
    }
  }

  // ---------- Gravity + Refill ----------
  async function applyGravity(){
    // ì•„ë˜ë¡œ ë–¨ì–´ëœ¨ë¦¬ê¸°: ê° ì—´ë§ˆë‹¤ ë¹ˆì¹¸ ë©”ìš°ê¸°
    for(let x=0;x<W;x++){
      let write = H-1;
      for(let y=H-1;y>=0;y--){
        if(grid[y][x]){
          if(write!==y){
            grid[write][x] = grid[y][x];
            grid[y][x] = null;
          }
          write--;
        }
      }
    }
    // ìœ„ì¹˜ ë°˜ì˜(ì• ë‹ˆë©”ì´ì…˜)
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const c = grid[y][x];
        if(!c) continue;
        const el = tilesById.get(c.id);
        if(el) moveTileEl(el, x, y);
      }
    }
    await sleep(190);
  }

  async function refill(){
    // ë¹ˆì¹¸ì— ìƒˆ íƒ€ì¼ ìƒì„± (ìœ„ì—ì„œ ë–¨ì–´ì ¸ ë‚´ë ¤ì˜¤ëŠ” ê²ƒì²˜ëŸ¼ ì‹œì‘ yë¥¼ ìŒìˆ˜ë¡œ ì¡ê³  ì´ë™)
    const spawned=[];
    for(let x=0;x<W;x++){
      for(let y=0;y<H;y++){
        if(grid[y][x]===null){
          const type = TYPES[(Math.random()*TYPES.length)|0];
          const c = { type, special: Special.NONE, id: makeId() };
          grid[y][x]=c;

          const el = createTileEl(c);
          tilesById.set(c.id, el);

          // ì‹œì‘ ìœ„ì¹˜: ìœ„ìª½
          const startY = -2 - (Math.random()*3)|0;
          const p0 = pos(x, startY);
          el.style.transform = `translate(${p0.x}px,${p0.y}px)`;
          // ë‹¤ìŒ í”„ë ˆì„ì— ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ë™
          spawned.push({el,x,y});
        }
      }
    }
    // next frame
    requestAnimationFrame(()=>{
      for(const s of spawned){
        moveTileEl(s.el, s.x, s.y);
      }
    });
    await sleep(210);
  }

  // ---------- UI ----------
  restartBtn.addEventListener("click", init);

  // start
  init();
})();
</script>
</body>
</html>

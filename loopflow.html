<!--
FIX: Ensure THREE is loaded before use + add self-tests and graceful fallbacks.
- Uses `defer` on CDN scripts and waits for DOMContentLoaded + poll for window.THREE.
- Adds a minimal self-test panel (THREE / OrbitControls / WebGL / Shader / Texture).
- Keeps original features: real photo refraction, ripple pulse on click, orbit drag, sliders.
- If `point.jpg` fails, loads a data-URL gradient placeholder.
-->
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>실사 포인트 + WebGL 물결</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    #app { position: fixed; inset: 0; }
    .ui { position: fixed; left: 12px; bottom: 12px; padding: 10px 12px; backdrop-filter: blur(8px); background: rgba(20,20,20,.35); border: 1px solid rgba(255,255,255,.15); border-radius: 12px; color: #fff; font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    .ui label { display: grid; grid-template-columns: 90px 1fr 44px; align-items: center; gap: 8px; margin: 6px 0; }
    .ui input[type=range] { width: 180px; }
    .badge { position: fixed; right: 12px; bottom: 12px; color: #bbb; font: 12px/1 system-ui; opacity: .85; }
    #float { position: fixed; width: clamp(24px, 3.5vw, 48px); pointer-events: none; transform: translate(-50%, -100%); filter: drop-shadow(0 2px 4px rgba(0,0,0,.6)); }

    .tests { position: fixed; left: 12px; top: 12px; padding: 10px 12px; background: rgba(10,10,10,.55); color:#eee; border:1px solid rgba(255,255,255,.15); border-radius:12px; font: 12px/1.2 system-ui; max-width: 320px; }
    .tests h3 { margin: 0 0 6px 0; font-size: 12px; font-weight: 700; color:#fff; }
    .tests ul { list-style: none; padding: 0; margin: 0; }
    .tests li { margin: 4px 0; }
    .ok { color: #79ffad; }
    .fail { color: #ff7d7d; }
    .hint { color:#a6b1ff; opacity:.9 }
    .small { opacity:.8; font-size: 11px; }
    .hide { display:none; }
  </style>
</head>
<body>
  <div id="app" aria-label="WebGL canvas mount"></div>
  <img id="float" src="./float.png" alt="float" />

  <div class="ui" role="region" aria-label="water controls">
    <label>Waves <input id="uAmp" type="range" min="0" max="1.5" step="0.01" value="0.55"><span id="ampV">0.55</span></label>
    <label>Chop <input id="uChop" type="range" min="0" max="2.0" step="0.01" value="0.9"><span id="chopV">0.90</span></label>
    <label>Speed <input id="uSpeed" type="range" min="0" max="2.0" step="0.01" value="0.6"><span id="speedV">0.60</span></label>
    <label>Ripple <input id="uRipple" type="range" min="0" max="2.0" step="0.01" value="0.8"><span id="rippleV">0.80</span></label>
  </div>
  <div class="badge">Click: Ripples • Drag: Orbit</div>

  <div class="tests" id="tests">
    <h3>Self‑Tests</h3>
    <ul id="testList">
      <li id="t1">1) THREE global available</li>
      <li id="t2">2) OrbitControls available</li>
      <li id="t3">3) WebGL context created</li>
      <li id="t4">4) Shaders compiled</li>
      <li id="t5">5) Texture loaded (point.jpg)</li>
    </ul>
    <div class="small hint">If something fails, check: network/CDN access, HTTPS, ad/script blockers.</div>
  </div>

  <!-- Three.js (deferred) -->
  <script defer src="https://unpkg.com/three@0.161.0/build/three.min.js"></script>
  <script defer src="https://unpkg.com/three@0.161.0/examples/js/controls/OrbitControls.js"></script>

  <!-- Vertex Shader -->
  <script id="vsh" type="x-shader/x-vertex">
  varying vec2 vUv;
  varying vec3 vWorldPos;
  uniform float uTime;
  uniform float uAmp;    // wave amplitude
  uniform float uChop;   // choppiness
  uniform float uSpeed;  // wave speed

  // 2D hash + noise
  float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453); }
  float noise(in vec2 p){
    vec2 i = floor(p);
    vec2 f = fract(p);
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    vec2 u = f*f*(3.0-2.0*f);
    return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;
  }

  void main(){
    vUv = uv;

    // base position
    vec3 pos = position;

    // multi-octave choppy waves
    float t = uTime * uSpeed;
    float amp = uAmp;
    float freq = 1.0;
    float ch = uChop;
    for(int i=0;i<5;i++){
      vec2 dir = normalize(vec2(cos(float(i)*2.39996), sin(float(i)*2.39996)));
      float n = noise(uv*freq + dir * t);
      float w = (n*2.0-1.0);
      // vertical displacement
      pos.z += w * amp / float(i+1);
      // horizontal choppiness (Gerstner-like)
      pos.x += dir.x * w * amp * ch / float(i+1) * 0.2;
      pos.y += dir.y * w * amp * ch / float(i+1) * 0.2;
      freq *= 2.0; // next octave
    }

    vec4 wp = modelMatrix * vec4(pos, 1.0);
    vWorldPos = wp.xyz;
    gl_Position = projectionMatrix * viewMatrix * wp;
  }
  </script>

  <!-- Fragment Shader -->
  <script id="fsh" type="x-shader/x-fragment">
  precision highp float;
  varying vec2 vUv;
  varying vec3 vWorldPos;
  uniform sampler2D uPhoto;    // background spot photo
  uniform vec2 uResolution;
  uniform float uTime;
  uniform float uRipple;

  // simple normal from height (finite diff on uv)
  float height(vec2 uv){
    // pseudo height from photo luminance (for subtle refraction variation)
    vec3 c = texture2D(uPhoto, uv).rgb;
    return dot(c, vec3(0.2126,0.7152,0.0722)) * 0.03;
  }

  void main(){
    // Screen-space uv (cover)
    vec2 uv = vUv;

    // derive normal-ish from photo (cheap) + time ripple
    float t = uTime*0.35;
    float h = height(uv + vec2(sin(t+uv.y*7.0), cos(t+uv.x*7.0))*0.002*uRipple);
    vec2 grad = vec2(height(uv+vec2(0.001,0.0)) - h, height(uv+vec2(0.0,0.001)) - h);
    vec2 flow = grad * 12.0; // magnify gradient for refraction

    // additional dynamic ripples (moving sine fields)
    flow += vec2(
      sin(uv.y*40.0 + t*3.5),
      cos(uv.x*40.0 - t*3.1)
    ) * 0.002 * uRipple;

    // refract the background photo
    vec2 refrUv = uv + flow;
    vec3 col = texture2D(uPhoto, refrUv).rgb;

    // cheap Fresnel-ish highlight
    float f = pow(1.0 - abs(dot(normalize(vec3(0.0,0.0,1.0)), normalize(vec3(flow,1.0)))), 2.0);
    vec3 highlight = vec3(0.8,0.9,1.0) * f * 0.15;

    gl_FragColor = vec4(col + highlight, 1.0);
  }
  </script>

  <script>
  // Minimal test helpers
  function mark(id, ok, note=""){
    const el = document.getElementById(id); if(!el) return;
    el.classList.remove('ok','fail'); el.classList.add(ok? 'ok':'fail');
    el.textContent = el.textContent.replace(/ - .*/,"") + (ok? ' - PASS' : ' - FAIL') + (note? ' \u2192 ' + note : '');
  }

  const PLACEHOLDER_DATA = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
    <svg xmlns="http://www.w3.org/2000/svg" width="1280" height="720">
      <defs>
        <linearGradient id="g" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0%" stop-color="#223"/>
          <stop offset="60%" stop-color="#1a2a3a"/>
          <stop offset="100%" stop-color="#0b1822"/>
        </linearGradient>
      </defs>
      <rect width="100%" height="100%" fill="url(#g)"/>
      <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#9ed0ff" font-family="system-ui" font-size="24">point.jpg not found — placeholder</text>
    </svg>`);

  // Wait for DOM + scripts
  document.addEventListener('DOMContentLoaded', () => {
    const start = async () => {
      // Poll for THREE to be available (handles slow CDN)
      let tries = 0; const maxTries = 100; // ~2s at 20ms
      while (typeof window.THREE === 'undefined' && tries < maxTries) {
        await new Promise(r => setTimeout(r, 20));
        tries++;
      }
      if (typeof window.THREE === 'undefined') {
        mark('t1', false, 'THREE not loaded (CDN blocked?)');
        console.error('THREE not loaded. Check network or CDN blocking.');
        return; // hard fail: nothing else to do
      }
      mark('t1', true);

      // Some builds expose OrbitControls on THREE
      if (typeof THREE.OrbitControls === 'function') mark('t2', true);
      else { mark('t2', false, 'OrbitControls missing'); }

      // Now run app
      try { runApp(); } catch (e) {
        console.error(e);
        mark('t3', false, 'App bootstrap error: ' + e.message);
      }
    };
    start();
  });

  function runApp(){
    const DPR = Math.min(window.devicePixelRatio || 1, 2);
    const app = document.getElementById('app');
    const floatEl = document.getElementById('float');

    // Check WebGL support early
    let glTestCanvas = document.createElement('canvas');
    let gl = glTestCanvas.getContext('webgl2') || glTestCanvas.getContext('webgl');
    const webglOk = !!gl; mark('t3', webglOk, webglOk? '' : 'WebGL unsupported');
    if(!webglOk){
      const warn = document.createElement('div');
      warn.style.cssText = 'position:fixed;inset:0;display:grid;place-items:center;color:#fff;background:#000;';
      warn.textContent = 'WebGL not supported by this browser/device.';
      document.body.appendChild(warn);
      return;
    }

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    camera.position.set(0, -1.2, 0.95);
    camera.lookAt(0,0,0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(DPR);
    renderer.setSize(window.innerWidth, window.innerHeight);
    app.appendChild(renderer.domElement);

    // Controls (if available)
    let controls = null;
    if (typeof THREE.OrbitControls === 'function') {
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.dampingFactor = 0.05;
      controls.minDistance = 0.35; controls.maxDistance = 3.0;
      controls.enablePan = false;
    }

    // Texture loader with fallback
    const loader = new THREE.TextureLoader();
    let textureLoaded = false;
    const photoTex = loader.load(
      './point.jpg',
      () => {
        // color space guard (support old/new three)
        if ('colorSpace' in photoTex && THREE.SRGBColorSpace) photoTex.colorSpace = THREE.SRGBColorSpace;
        else if ('encoding' in photoTex && THREE.sRGBEncoding) photoTex.encoding = THREE.sRGBEncoding;
        photoTex.wrapS = photoTex.wrapT = THREE.MirroredRepeatWrapping;
        textureLoaded = true; mark('t5', true);
      },
      undefined,
      () => {
        // onError → fallback placeholder
        const fallback = loader.load(PLACEHOLDER_DATA, ()=>{
          if ('colorSpace' in fallback && THREE.SRGBColorSpace) fallback.colorSpace = THREE.SRGBColorSpace;
          else if ('encoding' in fallback && THREE.sRGBEncoding) fallback.encoding = THREE.sRGBEncoding;
        });
        textureLoaded = true; mark('t5', true, 'using placeholder');
        uniforms.uPhoto.value = fallback;
      }
    );

    const uniforms = {
      uTime: { value: 0 },
      uAmp: { value: 0.55 },
      uChop: { value: 0.9 },
      uSpeed: { value: 0.6 },
      uRipple: { value: 0.8 },
      uPhoto: { value: photoTex },
      uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
    };

    const geo = new THREE.PlaneGeometry(2, 2, 256, 256);
    const vsh = document.getElementById('vsh').textContent;
    const fsh = document.getElementById('fsh').textContent;
    let mat, mesh;
    try {
      mat = new THREE.ShaderMaterial({ uniforms, vertexShader: vsh, fragmentShader: fsh, transparent: true });
      mesh = new THREE.Mesh(geo, mat);
      scene.add(mesh);
      mark('t4', true);
    } catch(err){
      console.error('Shader compile error', err);
      mark('t4', false, err.message);
    }

    // UI bindings
    const bind = (id, key, fmt=(v)=>(+v).toFixed(2)) => {
      const el = document.getElementById(id);
      const label = document.getElementById(id.replace('u','').toLowerCase()+ 'V') || el.nextElementSibling;
      el.addEventListener('input', ()=>{ uniforms[key].value = parseFloat(el.value); if(label) label.textContent = fmt(el.value); });
      return el;
    };
    bind('uAmp','uAmp'); bind('uChop','uChop'); bind('uSpeed','uSpeed'); bind('uRipple','uRipple');

    // Click to add local ripple via brief parameter spike + float bobbing
    let clickPulse = 0;
    renderer.domElement.addEventListener('pointerdown', (e)=>{
      clickPulse = 1.0;
      floatEl.style.left = `${e.clientX}px`;
      floatEl.style.top = `${e.clientY}px`;
      floatEl.animate([
        { transform: 'translate(-50%, -100%)' },
        { transform: 'translate(-50%, -110%)' },
        { transform: 'translate(-50%, -100%)' }
      ], { duration: 600, easing: 'ease-in-out' });
    });

    // Resize
    function resize(){
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h; camera.updateProjectionMatrix();
      uniforms.uResolution.value.set(w, h);
    }
    window.addEventListener('resize', resize);
    resize();

    // Animate
    const clock = new THREE.Clock();
    function tick(){
      const dt = clock.getDelta();
      uniforms.uTime.value += dt;

      if(clickPulse > 0){
        uniforms.uRipple.value = Math.min(2.0, uniforms.uRipple.value + clickPulse*0.4);
        clickPulse *= 0.88;
      }

      if(controls) controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    tick();
  }
  </script>
</body>
</html>
